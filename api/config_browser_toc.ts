// Code generated by protoc-gen-browser. DO NOT EDIT.
// version:
// 	protoc-gen-browser v0.0.77<br />
// 	protoc             v3.21.11<br />
// source: api/config.proto<br />

import Axios from "axios";

export interface Error{
	code: number;
	msg: string;
}

export interface AppsReq{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	project_id: Array<number>|null|undefined;
	groupname: string;
	search_filter: string;
}
function AppsReqToJson(msg: AppsReq): string{
	let s: string="{"
	//project_id
	if(msg.project_id==null||msg.project_id==undefined){
		s+='"project_id":null,'
	}else if(msg.project_id.length==0){
		s+='"project_id":[],'
	}else{
		s+='"project_id":['
		for(let element of msg.project_id){
			if(element==null||element==undefined||!Number.isInteger(element)){
				throw 'element in AppsReq.project_id must be integer'
			}
			if(element>4294967295||element<0){
				throw 'element in AppsReq.project_id overflow'
			}
			s+=element+','
		}
		s=s.substr(0,s.length-1)+'],'
	}
	//groupname
	if(msg.groupname==null||msg.groupname==undefined){
		throw 'AppsReq.groupname must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.groupname)
		s+='"groupname":'+vv+','
	}
	//search_filter
	if(msg.search_filter==null||msg.search_filter==undefined){
		throw 'AppsReq.search_filter must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.search_filter)
		s+='"search_filter":'+vv+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface AppsResp{
	apps: Array<string>|null|undefined;
}
function JsonToAppsResp(jsonobj: { [k:string]:any }): AppsResp{
	let obj: AppsResp={
		apps:null,
	}
	//apps
	if(jsonobj['apps']!=null&&jsonobj['apps']!=undefined){
		if(!(jsonobj['apps'] instanceof Array)){
			throw 'AppsResp.apps must be Array<string>|null|undefined'
		}
		for(let element of jsonobj['apps']){
			if(typeof element!='string'){
				throw 'element in AppsResp.apps must be string'
			}
			if(obj['apps']==undefined){
				obj['apps']=new Array<string>
			}
			obj['apps'].push(element)
		}
	}
	return obj
}
export interface CreateAppReq{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	project_id: Array<number>|null|undefined;
	groupname: string;
	appname: string;
	secret: string;
}
function CreateAppReqToJson(msg: CreateAppReq): string{
	let s: string="{"
	//project_id
	if(msg.project_id==null||msg.project_id==undefined){
		s+='"project_id":null,'
	}else if(msg.project_id.length==0){
		s+='"project_id":[],'
	}else{
		s+='"project_id":['
		for(let element of msg.project_id){
			if(element==null||element==undefined||!Number.isInteger(element)){
				throw 'element in CreateAppReq.project_id must be integer'
			}
			if(element>4294967295||element<0){
				throw 'element in CreateAppReq.project_id overflow'
			}
			s+=element+','
		}
		s=s.substr(0,s.length-1)+'],'
	}
	//groupname
	if(msg.groupname==null||msg.groupname==undefined){
		throw 'CreateAppReq.groupname must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.groupname)
		s+='"groupname":'+vv+','
	}
	//appname
	if(msg.appname==null||msg.appname==undefined){
		throw 'CreateAppReq.appname must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.appname)
		s+='"appname":'+vv+','
	}
	//secret
	if(msg.secret==null||msg.secret==undefined){
		throw 'CreateAppReq.secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.secret)
		s+='"secret":'+vv+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface CreateAppResp{
}
function JsonToCreateAppResp(jsonobj: { [k:string]:any }): CreateAppResp{
	let obj: CreateAppResp={
	}
	return obj
}
export interface DelAppReq{
	groupname: string;
	appname: string;
	secret: string;
}
function DelAppReqToJson(msg: DelAppReq): string{
	let s: string="{"
	//groupname
	if(msg.groupname==null||msg.groupname==undefined){
		throw 'DelAppReq.groupname must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.groupname)
		s+='"groupname":'+vv+','
	}
	//appname
	if(msg.appname==null||msg.appname==undefined){
		throw 'DelAppReq.appname must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.appname)
		s+='"appname":'+vv+','
	}
	//secret
	if(msg.secret==null||msg.secret==undefined){
		throw 'DelAppReq.secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.secret)
		s+='"secret":'+vv+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface DelAppResp{
}
function JsonToDelAppResp(jsonobj: { [k:string]:any }): DelAppResp{
	let obj: DelAppResp={
	}
	return obj
}
export interface DelKeyReq{
	groupname: string;
	appname: string;
	key: string;
	secret: string;
}
function DelKeyReqToJson(msg: DelKeyReq): string{
	let s: string="{"
	//groupname
	if(msg.groupname==null||msg.groupname==undefined){
		throw 'DelKeyReq.groupname must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.groupname)
		s+='"groupname":'+vv+','
	}
	//appname
	if(msg.appname==null||msg.appname==undefined){
		throw 'DelKeyReq.appname must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.appname)
		s+='"appname":'+vv+','
	}
	//key
	if(msg.key==null||msg.key==undefined){
		throw 'DelKeyReq.key must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.key)
		s+='"key":'+vv+','
	}
	//secret
	if(msg.secret==null||msg.secret==undefined){
		throw 'DelKeyReq.secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.secret)
		s+='"secret":'+vv+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface DelKeyResp{
}
function JsonToDelKeyResp(jsonobj: { [k:string]:any }): DelKeyResp{
	let obj: DelKeyResp={
	}
	return obj
}
export interface GetKeyConfigReq{
	groupname: string;
	appname: string;
	key: string;
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	index: number;//0 means return current active config,config's index start from 1
	secret: string;
}
function GetKeyConfigReqToJson(msg: GetKeyConfigReq): string{
	let s: string="{"
	//groupname
	if(msg.groupname==null||msg.groupname==undefined){
		throw 'GetKeyConfigReq.groupname must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.groupname)
		s+='"groupname":'+vv+','
	}
	//appname
	if(msg.appname==null||msg.appname==undefined){
		throw 'GetKeyConfigReq.appname must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.appname)
		s+='"appname":'+vv+','
	}
	//key
	if(msg.key==null||msg.key==undefined){
		throw 'GetKeyConfigReq.key must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.key)
		s+='"key":'+vv+','
	}
	//index
	if(msg.index==null||msg.index==undefined||!Number.isInteger(msg.index)){
		throw 'GetKeyConfigReq.index must be integer'
	}else if(msg.index>4294967295||msg.index<0){
		throw 'GetKeyConfigReq.index overflow'
	}else{
		s+='"index":'+msg.index+','
	}
	//secret
	if(msg.secret==null||msg.secret==undefined){
		throw 'GetKeyConfigReq.secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.secret)
		s+='"secret":'+vv+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface GetKeyConfigResp{
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	cur_index: number;//current active config index,0 means not exist
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	max_index: number;//current max config index,0 means not exist
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	cur_version: number;//current active config version,config's version start from 1
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	this_index: number;//the config data below belong's to which index
	value: string;
	value_type: string;
}
function JsonToGetKeyConfigResp(jsonobj: { [k:string]:any }): GetKeyConfigResp{
	let obj: GetKeyConfigResp={
		cur_index:0,
		max_index:0,
		cur_version:0,
		this_index:0,
		value:'',
		value_type:'',
	}
	//cur_index
	if(jsonobj['cur_index']!=null&&jsonobj['cur_index']!=undefined){
		if(typeof jsonobj['cur_index']!='number'||!Number.isInteger(jsonobj['cur_index'])){
			throw 'GetKeyConfigResp.cur_index must be integer'
		}else if(jsonobj['cur_index']>4294967295||jsonobj['cur_index']<0){
			throw 'GetKeyConfigResp.cur_index overflow'
		}
		obj['cur_index']=jsonobj['cur_index']
	}
	//max_index
	if(jsonobj['max_index']!=null&&jsonobj['max_index']!=undefined){
		if(typeof jsonobj['max_index']!='number'||!Number.isInteger(jsonobj['max_index'])){
			throw 'GetKeyConfigResp.max_index must be integer'
		}else if(jsonobj['max_index']>4294967295||jsonobj['max_index']<0){
			throw 'GetKeyConfigResp.max_index overflow'
		}
		obj['max_index']=jsonobj['max_index']
	}
	//cur_version
	if(jsonobj['cur_version']!=null&&jsonobj['cur_version']!=undefined){
		if(typeof jsonobj['cur_version']!='number'||!Number.isInteger(jsonobj['cur_version'])){
			throw 'GetKeyConfigResp.cur_version must be integer'
		}else if(jsonobj['cur_version']>4294967295||jsonobj['cur_version']<0){
			throw 'GetKeyConfigResp.cur_version overflow'
		}
		obj['cur_version']=jsonobj['cur_version']
	}
	//this_index
	if(jsonobj['this_index']!=null&&jsonobj['this_index']!=undefined){
		if(typeof jsonobj['this_index']!='number'||!Number.isInteger(jsonobj['this_index'])){
			throw 'GetKeyConfigResp.this_index must be integer'
		}else if(jsonobj['this_index']>4294967295||jsonobj['this_index']<0){
			throw 'GetKeyConfigResp.this_index overflow'
		}
		obj['this_index']=jsonobj['this_index']
	}
	//value
	if(jsonobj['value']!=null&&jsonobj['value']!=undefined){
		if(typeof jsonobj['value']!='string'){
			throw 'GetKeyConfigResp.value must be string'
		}
		obj['value']=jsonobj['value']
	}
	//value_type
	if(jsonobj['value_type']!=null&&jsonobj['value_type']!=undefined){
		if(typeof jsonobj['value_type']!='string'){
			throw 'GetKeyConfigResp.value_type must be string'
		}
		obj['value_type']=jsonobj['value_type']
	}
	return obj
}
export interface GroupsReq{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	project_id: Array<number>|null|undefined;
	search_filter: string;
}
function GroupsReqToJson(msg: GroupsReq): string{
	let s: string="{"
	//project_id
	if(msg.project_id==null||msg.project_id==undefined){
		s+='"project_id":null,'
	}else if(msg.project_id.length==0){
		s+='"project_id":[],'
	}else{
		s+='"project_id":['
		for(let element of msg.project_id){
			if(element==null||element==undefined||!Number.isInteger(element)){
				throw 'element in GroupsReq.project_id must be integer'
			}
			if(element>4294967295||element<0){
				throw 'element in GroupsReq.project_id overflow'
			}
			s+=element+','
		}
		s=s.substr(0,s.length-1)+'],'
	}
	//search_filter
	if(msg.search_filter==null||msg.search_filter==undefined){
		throw 'GroupsReq.search_filter must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.search_filter)
		s+='"search_filter":'+vv+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface GroupsResp{
	groups: Array<string>|null|undefined;
}
function JsonToGroupsResp(jsonobj: { [k:string]:any }): GroupsResp{
	let obj: GroupsResp={
		groups:null,
	}
	//groups
	if(jsonobj['groups']!=null&&jsonobj['groups']!=undefined){
		if(!(jsonobj['groups'] instanceof Array)){
			throw 'GroupsResp.groups must be Array<string>|null|undefined'
		}
		for(let element of jsonobj['groups']){
			if(typeof element!='string'){
				throw 'element in GroupsResp.groups must be string'
			}
			if(obj['groups']==undefined){
				obj['groups']=new Array<string>
			}
			obj['groups'].push(element)
		}
	}
	return obj
}
export interface KeysReq{
	groupname: string;
	appname: string;
	secret: string;
}
function KeysReqToJson(msg: KeysReq): string{
	let s: string="{"
	//groupname
	if(msg.groupname==null||msg.groupname==undefined){
		throw 'KeysReq.groupname must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.groupname)
		s+='"groupname":'+vv+','
	}
	//appname
	if(msg.appname==null||msg.appname==undefined){
		throw 'KeysReq.appname must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.appname)
		s+='"appname":'+vv+','
	}
	//secret
	if(msg.secret==null||msg.secret==undefined){
		throw 'KeysReq.secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.secret)
		s+='"secret":'+vv+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface KeysResp{
	keys: Array<string>|null|undefined;
}
function JsonToKeysResp(jsonobj: { [k:string]:any }): KeysResp{
	let obj: KeysResp={
		keys:null,
	}
	//keys
	if(jsonobj['keys']!=null&&jsonobj['keys']!=undefined){
		if(!(jsonobj['keys'] instanceof Array)){
			throw 'KeysResp.keys must be Array<string>|null|undefined'
		}
		for(let element of jsonobj['keys']){
			if(typeof element!='string'){
				throw 'element in KeysResp.keys must be string'
			}
			if(obj['keys']==undefined){
				obj['keys']=new Array<string>
			}
			obj['keys'].push(element)
		}
	}
	return obj
}
export interface ProxyReq{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	project_id: Array<number>|null|undefined;
	path: string;
	appname: string;
	groupname: string;
	data: string;
}
function ProxyReqToJson(msg: ProxyReq): string{
	let s: string="{"
	//project_id
	if(msg.project_id==null||msg.project_id==undefined){
		s+='"project_id":null,'
	}else if(msg.project_id.length==0){
		s+='"project_id":[],'
	}else{
		s+='"project_id":['
		for(let element of msg.project_id){
			if(element==null||element==undefined||!Number.isInteger(element)){
				throw 'element in ProxyReq.project_id must be integer'
			}
			if(element>4294967295||element<0){
				throw 'element in ProxyReq.project_id overflow'
			}
			s+=element+','
		}
		s=s.substr(0,s.length-1)+'],'
	}
	//path
	if(msg.path==null||msg.path==undefined){
		throw 'ProxyReq.path must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.path)
		s+='"path":'+vv+','
	}
	//appname
	if(msg.appname==null||msg.appname==undefined){
		throw 'ProxyReq.appname must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.appname)
		s+='"appname":'+vv+','
	}
	//groupname
	if(msg.groupname==null||msg.groupname==undefined){
		throw 'ProxyReq.groupname must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.groupname)
		s+='"groupname":'+vv+','
	}
	//data
	if(msg.data==null||msg.data==undefined){
		throw 'ProxyReq.data must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.data)
		s+='"data":'+vv+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface ProxyResp{
	data: string;
}
function JsonToProxyResp(jsonobj: { [k:string]:any }): ProxyResp{
	let obj: ProxyResp={
		data:'',
	}
	//data
	if(jsonobj['data']!=null&&jsonobj['data']!=undefined){
		if(typeof jsonobj['data']!='string'){
			throw 'ProxyResp.data must be string'
		}
		obj['data']=jsonobj['data']
	}
	return obj
}
export interface RollbackReq{
	groupname: string;
	appname: string;
	key: string;
	secret: string;
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	index: number;
}
function RollbackReqToJson(msg: RollbackReq): string{
	let s: string="{"
	//groupname
	if(msg.groupname==null||msg.groupname==undefined){
		throw 'RollbackReq.groupname must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.groupname)
		s+='"groupname":'+vv+','
	}
	//appname
	if(msg.appname==null||msg.appname==undefined){
		throw 'RollbackReq.appname must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.appname)
		s+='"appname":'+vv+','
	}
	//key
	if(msg.key==null||msg.key==undefined){
		throw 'RollbackReq.key must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.key)
		s+='"key":'+vv+','
	}
	//secret
	if(msg.secret==null||msg.secret==undefined){
		throw 'RollbackReq.secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.secret)
		s+='"secret":'+vv+','
	}
	//index
	if(msg.index==null||msg.index==undefined||!Number.isInteger(msg.index)){
		throw 'RollbackReq.index must be integer'
	}else if(msg.index>4294967295||msg.index<0){
		throw 'RollbackReq.index overflow'
	}else{
		s+='"index":'+msg.index+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface RollbackResp{
}
function JsonToRollbackResp(jsonobj: { [k:string]:any }): RollbackResp{
	let obj: RollbackResp={
	}
	return obj
}
export interface SetKeyConfigReq{
	groupname: string;
	appname: string;
	key: string;
	value: string;
	value_type: string;
	secret: string;
}
function SetKeyConfigReqToJson(msg: SetKeyConfigReq): string{
	let s: string="{"
	//groupname
	if(msg.groupname==null||msg.groupname==undefined){
		throw 'SetKeyConfigReq.groupname must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.groupname)
		s+='"groupname":'+vv+','
	}
	//appname
	if(msg.appname==null||msg.appname==undefined){
		throw 'SetKeyConfigReq.appname must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.appname)
		s+='"appname":'+vv+','
	}
	//key
	if(msg.key==null||msg.key==undefined){
		throw 'SetKeyConfigReq.key must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.key)
		s+='"key":'+vv+','
	}
	//value
	if(msg.value==null||msg.value==undefined){
		throw 'SetKeyConfigReq.value must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.value)
		s+='"value":'+vv+','
	}
	//value_type
	if(msg.value_type==null||msg.value_type==undefined){
		throw 'SetKeyConfigReq.value_type must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.value_type)
		s+='"value_type":'+vv+','
	}
	//secret
	if(msg.secret==null||msg.secret==undefined){
		throw 'SetKeyConfigReq.secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.secret)
		s+='"secret":'+vv+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface SetKeyConfigResp{
}
function JsonToSetKeyConfigResp(jsonobj: { [k:string]:any }): SetKeyConfigResp{
	let obj: SetKeyConfigResp={
	}
	return obj
}
export interface UpdateAppSecretReq{
	groupname: string;
	appname: string;
	old_secret: string;
	new_secret: string;
}
function UpdateAppSecretReqToJson(msg: UpdateAppSecretReq): string{
	let s: string="{"
	//groupname
	if(msg.groupname==null||msg.groupname==undefined){
		throw 'UpdateAppSecretReq.groupname must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.groupname)
		s+='"groupname":'+vv+','
	}
	//appname
	if(msg.appname==null||msg.appname==undefined){
		throw 'UpdateAppSecretReq.appname must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.appname)
		s+='"appname":'+vv+','
	}
	//old_secret
	if(msg.old_secret==null||msg.old_secret==undefined){
		throw 'UpdateAppSecretReq.old_secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.old_secret)
		s+='"old_secret":'+vv+','
	}
	//new_secret
	if(msg.new_secret==null||msg.new_secret==undefined){
		throw 'UpdateAppSecretReq.new_secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.new_secret)
		s+='"new_secret":'+vv+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface UpdateAppSecretResp{
}
function JsonToUpdateAppSecretResp(jsonobj: { [k:string]:any }): UpdateAppSecretResp{
	let obj: UpdateAppSecretResp={
	}
	return obj
}
export interface WatchData{
	key: string;
	value: string;
	value_type: string;
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	version: number;
}
function JsonToWatchData(jsonobj: { [k:string]:any }): WatchData{
	let obj: WatchData={
		key:'',
		value:'',
		value_type:'',
		version:0,
	}
	//key
	if(jsonobj['key']!=null&&jsonobj['key']!=undefined){
		if(typeof jsonobj['key']!='string'){
			throw 'WatchData.key must be string'
		}
		obj['key']=jsonobj['key']
	}
	//value
	if(jsonobj['value']!=null&&jsonobj['value']!=undefined){
		if(typeof jsonobj['value']!='string'){
			throw 'WatchData.value must be string'
		}
		obj['value']=jsonobj['value']
	}
	//value_type
	if(jsonobj['value_type']!=null&&jsonobj['value_type']!=undefined){
		if(typeof jsonobj['value_type']!='string'){
			throw 'WatchData.value_type must be string'
		}
		obj['value_type']=jsonobj['value_type']
	}
	//version
	if(jsonobj['version']!=null&&jsonobj['version']!=undefined){
		if(typeof jsonobj['version']!='number'||!Number.isInteger(jsonobj['version'])){
			throw 'WatchData.version must be integer'
		}else if(jsonobj['version']>4294967295||jsonobj['version']<0){
			throw 'WatchData.version overflow'
		}
		obj['version']=jsonobj['version']
	}
	return obj
}
export interface WatchReq{
	groupname: string;
	appname: string;
	//map's key is config's keyname,map's value is config's cur version
	//if cur version == 0 means return current active config
	//if all cur version is the newest,the request will block until a new version come
	//if some keys' version is the newest,and some keys' version is old,then the keys with old version will return newest version and datas,the newest's keys will only return version
	//Warning!!!map's value's type is uint32,be careful of sign(+) and overflow
	keys: Map<string,number>|null|undefined;
}
function WatchReqToJson(msg: WatchReq): string{
	let s: string="{"
	//groupname
	if(msg.groupname==null||msg.groupname==undefined){
		throw 'WatchReq.groupname must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.groupname)
		s+='"groupname":'+vv+','
	}
	//appname
	if(msg.appname==null||msg.appname==undefined){
		throw 'WatchReq.appname must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.appname)
		s+='"appname":'+vv+','
	}
	//keys
	if(msg.keys==null||msg.keys==undefined){
		s+='"keys":null,'
	}else if (msg.keys.size==0){
		s+='"keys":{},'
	}else{
		s+='"keys":{'
		for(let kv of msg.keys.entries()){
			if(kv[0]==null||kv[0]==undefined){
				throw "map's key in WatchReq.keys must be string"
			}
			//transfer the json escape
			let vv=JSON.stringify(kv[0])
			s+=vv+':'
			if(kv[1]==null||kv[1]==undefined||!Number.isInteger(kv[1])){
				throw "map's value in WatchReq.keys must be integer"
			}else if(kv[1]>4294967295||kv[1]<0){
				throw "map's value in WatchReq.keys overflow"
			}
			s+=kv[1]+','
		}
		s=s.substr(0,s.length-1)+'},'
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface WatchResp{
	datas: Map<string,WatchData|null|undefined>|null|undefined;
}
function JsonToWatchResp(jsonobj: { [k:string]:any }): WatchResp{
	let obj: WatchResp={
		datas:null,
	}
	//datas
	if(jsonobj['datas']!=null&&jsonobj['datas']!=undefined){
		if(typeof jsonobj['datas']!='object'){
			throw 'WatchResp.datas must be Map<string,WatchData|null|undefined>|null|undefined'
		}
		for(let key of Object.keys(jsonobj['datas'])){
			let value=jsonobj['datas'][key]
			let k: string=key
			let v: WatchData|null|undefined=null
			if(typeof value==null||typeof value==undefined){
				v=null
			}else if(typeof value!='object'){
				throw 'value in WatchResp.datas must be WatchData|null|undefined'
			}else{
				v=JsonToWatchData(value)
			}
			if(obj['datas']==undefined){
				obj['datas']=new Map<string,WatchData|null|undefined>
			}
			obj['datas'].set(k,v)
		}
	}
	return obj
}
const _WebPathConfigGroups: string ="/admin.config/groups";
const _WebPathConfigApps: string ="/admin.config/apps";
const _WebPathConfigCreateApp: string ="/admin.config/create_app";
const _WebPathConfigDelApp: string ="/admin.config/del_app";
const _WebPathConfigUpdateAppSecret: string ="/admin.config/update_app_secret";
const _WebPathConfigKeys: string ="/admin.config/keys";
const _WebPathConfigDelKey: string ="/admin.config/del_key";
const _WebPathConfigGetKeyConfig: string ="/admin.config/get_key_config";
const _WebPathConfigSetKeyConfig: string ="/admin.config/set_key_config";
const _WebPathConfigRollback: string ="/admin.config/rollback";
const _WebPathConfigWatch: string ="/admin.config/watch";
const _WebPathConfigProxy: string ="/admin.config/proxy";
//ToC means this is used for users
export class ConfigBrowserClientToC {
	constructor(host: string){
		if(host==null||host==undefined||host.length==0){
			throw "ConfigBrowserClientToC's host missing"
		}
		this.host=host
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	groups(header: { [k: string]: string },req: GroupsReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: GroupsResp)=>void){
		if(!Number.isInteger(timeout)){
			throw 'timeout must be integer'
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let config={
			url:_WebPathConfigGroups,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: GroupsReqToJson(req),
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			try{
				let obj:GroupsResp=JsonToGroupsResp(response.data)
				successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'response error'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	apps(header: { [k: string]: string },req: AppsReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: AppsResp)=>void){
		if(!Number.isInteger(timeout)){
			throw 'timeout must be integer'
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let config={
			url:_WebPathConfigApps,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: AppsReqToJson(req),
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			try{
				let obj:AppsResp=JsonToAppsResp(response.data)
				successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'response error'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	create_app(header: { [k: string]: string },req: CreateAppReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: CreateAppResp)=>void){
		if(!Number.isInteger(timeout)){
			throw 'timeout must be integer'
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let config={
			url:_WebPathConfigCreateApp,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: CreateAppReqToJson(req),
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			try{
				let obj:CreateAppResp=JsonToCreateAppResp(response.data)
				successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'response error'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	del_app(header: { [k: string]: string },req: DelAppReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: DelAppResp)=>void){
		if(!Number.isInteger(timeout)){
			throw 'timeout must be integer'
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let config={
			url:_WebPathConfigDelApp,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: DelAppReqToJson(req),
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			try{
				let obj:DelAppResp=JsonToDelAppResp(response.data)
				successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'response error'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	update_app_secret(header: { [k: string]: string },req: UpdateAppSecretReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: UpdateAppSecretResp)=>void){
		if(!Number.isInteger(timeout)){
			throw 'timeout must be integer'
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let config={
			url:_WebPathConfigUpdateAppSecret,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: UpdateAppSecretReqToJson(req),
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			try{
				let obj:UpdateAppSecretResp=JsonToUpdateAppSecretResp(response.data)
				successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'response error'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	keys(header: { [k: string]: string },req: KeysReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: KeysResp)=>void){
		if(!Number.isInteger(timeout)){
			throw 'timeout must be integer'
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let config={
			url:_WebPathConfigKeys,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: KeysReqToJson(req),
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			try{
				let obj:KeysResp=JsonToKeysResp(response.data)
				successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'response error'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	del_key(header: { [k: string]: string },req: DelKeyReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: DelKeyResp)=>void){
		if(!Number.isInteger(timeout)){
			throw 'timeout must be integer'
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let config={
			url:_WebPathConfigDelKey,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: DelKeyReqToJson(req),
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			try{
				let obj:DelKeyResp=JsonToDelKeyResp(response.data)
				successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'response error'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	get_key_config(header: { [k: string]: string },req: GetKeyConfigReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: GetKeyConfigResp)=>void){
		if(!Number.isInteger(timeout)){
			throw 'timeout must be integer'
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let config={
			url:_WebPathConfigGetKeyConfig,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: GetKeyConfigReqToJson(req),
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			try{
				let obj:GetKeyConfigResp=JsonToGetKeyConfigResp(response.data)
				successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'response error'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	set_key_config(header: { [k: string]: string },req: SetKeyConfigReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: SetKeyConfigResp)=>void){
		if(!Number.isInteger(timeout)){
			throw 'timeout must be integer'
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let config={
			url:_WebPathConfigSetKeyConfig,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: SetKeyConfigReqToJson(req),
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			try{
				let obj:SetKeyConfigResp=JsonToSetKeyConfigResp(response.data)
				successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'response error'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	rollback(header: { [k: string]: string },req: RollbackReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: RollbackResp)=>void){
		if(!Number.isInteger(timeout)){
			throw 'timeout must be integer'
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let config={
			url:_WebPathConfigRollback,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: RollbackReqToJson(req),
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			try{
				let obj:RollbackResp=JsonToRollbackResp(response.data)
				successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'response error'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	watch(header: { [k: string]: string },req: WatchReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: WatchResp)=>void){
		if(!Number.isInteger(timeout)){
			throw 'timeout must be integer'
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let config={
			url:_WebPathConfigWatch,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: WatchReqToJson(req),
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			try{
				let obj:WatchResp=JsonToWatchResp(response.data)
				successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'response error'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	proxy(header: { [k: string]: string },req: ProxyReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: ProxyResp)=>void){
		if(!Number.isInteger(timeout)){
			throw 'timeout must be integer'
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let config={
			url:_WebPathConfigProxy,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: ProxyReqToJson(req),
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			try{
				let obj:ProxyResp=JsonToProxyResp(response.data)
				successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'response error'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	private host: string
}
