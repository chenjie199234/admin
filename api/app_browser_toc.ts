// Code generated by protoc-gen-browser. DO NOT EDIT.
// version:
// 	protoc-gen-browser v0.0.79<br />
// 	protoc             v4.24.1<br />
// source: api/app.proto<br />

import Axios from "axios";

export interface Error{
	code: number;
	msg: string;
}

export interface CreateAppReq{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	project_id: Array<number>|null|undefined;
	g_name: string;
	a_name: string;
	secret: string;
}
function CreateAppReqToJson(msg: CreateAppReq): string{
	let s: string="{"
	//project_id
	if(msg.project_id==null||msg.project_id==undefined){
		s+='"project_id":null,'
	}else if(msg.project_id.length==0){
		s+='"project_id":[],'
	}else{
		s+='"project_id":['
		for(let element of msg.project_id){
			if(element==null||element==undefined||!Number.isInteger(element)){
				throw 'element in CreateAppReq.project_id must be integer'
			}
			if(element>4294967295||element<0){
				throw 'element in CreateAppReq.project_id overflow'
			}
			s+=element+','
		}
		s=s.substr(0,s.length-1)+'],'
	}
	//g_name
	if(msg.g_name==null||msg.g_name==undefined){
		throw 'CreateAppReq.g_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.g_name)
		s+='"g_name":'+vv+','
	}
	//a_name
	if(msg.a_name==null||msg.a_name==undefined){
		throw 'CreateAppReq.a_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.a_name)
		s+='"a_name":'+vv+','
	}
	//secret
	if(msg.secret==null||msg.secret==undefined){
		throw 'CreateAppReq.secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.secret)
		s+='"secret":'+vv+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface CreateAppResp{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	node_id: Array<number>|null|undefined;
}
function JsonToCreateAppResp(jsonobj: { [k:string]:any }): CreateAppResp{
	let obj: CreateAppResp={
		node_id:null,
	}
	//node_id
	if(jsonobj['node_id']!=null&&jsonobj['node_id']!=undefined){
		if(!(jsonobj['node_id'] instanceof Array)){
			throw 'CreateAppResp.node_id must be Array<number>|null|undefined'
		}
		for(let element of jsonobj['node_id']){
			if(typeof element!='number'||!Number.isInteger(element)){
				throw 'element in CreateAppResp.node_id must be integer'
			}else if(element>4294967295||element<0){
				throw 'element in CreateAppResp.node_id overflow'
			}
			if(obj['node_id']==null){
				obj['node_id']=new Array<number>
			}
			obj['node_id'].push(element)
		}
	}
	return obj
}
export interface DelAppReq{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	project_id: Array<number>|null|undefined;
	g_name: string;
	a_name: string;
	secret: string;
}
function DelAppReqToJson(msg: DelAppReq): string{
	let s: string="{"
	//project_id
	if(msg.project_id==null||msg.project_id==undefined){
		s+='"project_id":null,'
	}else if(msg.project_id.length==0){
		s+='"project_id":[],'
	}else{
		s+='"project_id":['
		for(let element of msg.project_id){
			if(element==null||element==undefined||!Number.isInteger(element)){
				throw 'element in DelAppReq.project_id must be integer'
			}
			if(element>4294967295||element<0){
				throw 'element in DelAppReq.project_id overflow'
			}
			s+=element+','
		}
		s=s.substr(0,s.length-1)+'],'
	}
	//g_name
	if(msg.g_name==null||msg.g_name==undefined){
		throw 'DelAppReq.g_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.g_name)
		s+='"g_name":'+vv+','
	}
	//a_name
	if(msg.a_name==null||msg.a_name==undefined){
		throw 'DelAppReq.a_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.a_name)
		s+='"a_name":'+vv+','
	}
	//secret
	if(msg.secret==null||msg.secret==undefined){
		throw 'DelAppReq.secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.secret)
		s+='"secret":'+vv+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface DelAppResp{
}
function JsonToDelAppResp(_jsonobj: { [k:string]:any }): DelAppResp{
	let obj: DelAppResp={
	}
	return obj
}
export interface DelKeyReq{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	project_id: Array<number>|null|undefined;
	g_name: string;
	a_name: string;
	key: string;//can't contain '.' in key
	secret: string;
}
function DelKeyReqToJson(msg: DelKeyReq): string{
	let s: string="{"
	//project_id
	if(msg.project_id==null||msg.project_id==undefined){
		s+='"project_id":null,'
	}else if(msg.project_id.length==0){
		s+='"project_id":[],'
	}else{
		s+='"project_id":['
		for(let element of msg.project_id){
			if(element==null||element==undefined||!Number.isInteger(element)){
				throw 'element in DelKeyReq.project_id must be integer'
			}
			if(element>4294967295||element<0){
				throw 'element in DelKeyReq.project_id overflow'
			}
			s+=element+','
		}
		s=s.substr(0,s.length-1)+'],'
	}
	//g_name
	if(msg.g_name==null||msg.g_name==undefined){
		throw 'DelKeyReq.g_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.g_name)
		s+='"g_name":'+vv+','
	}
	//a_name
	if(msg.a_name==null||msg.a_name==undefined){
		throw 'DelKeyReq.a_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.a_name)
		s+='"a_name":'+vv+','
	}
	//key
	if(msg.key==null||msg.key==undefined){
		throw 'DelKeyReq.key must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.key)
		s+='"key":'+vv+','
	}
	//secret
	if(msg.secret==null||msg.secret==undefined){
		throw 'DelKeyReq.secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.secret)
		s+='"secret":'+vv+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface DelKeyResp{
}
function JsonToDelKeyResp(_jsonobj: { [k:string]:any }): DelKeyResp{
	let obj: DelKeyResp={
	}
	return obj
}
export interface DelProxyReq{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	project_id: Array<number>|null|undefined;
	g_name: string;
	a_name: string;
	path: string;
	secret: string;
}
function DelProxyReqToJson(msg: DelProxyReq): string{
	let s: string="{"
	//project_id
	if(msg.project_id==null||msg.project_id==undefined){
		s+='"project_id":null,'
	}else if(msg.project_id.length==0){
		s+='"project_id":[],'
	}else{
		s+='"project_id":['
		for(let element of msg.project_id){
			if(element==null||element==undefined||!Number.isInteger(element)){
				throw 'element in DelProxyReq.project_id must be integer'
			}
			if(element>4294967295||element<0){
				throw 'element in DelProxyReq.project_id overflow'
			}
			s+=element+','
		}
		s=s.substr(0,s.length-1)+'],'
	}
	//g_name
	if(msg.g_name==null||msg.g_name==undefined){
		throw 'DelProxyReq.g_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.g_name)
		s+='"g_name":'+vv+','
	}
	//a_name
	if(msg.a_name==null||msg.a_name==undefined){
		throw 'DelProxyReq.a_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.a_name)
		s+='"a_name":'+vv+','
	}
	//path
	if(msg.path==null||msg.path==undefined){
		throw 'DelProxyReq.path must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.path)
		s+='"path":'+vv+','
	}
	//secret
	if(msg.secret==null||msg.secret==undefined){
		throw 'DelProxyReq.secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.secret)
		s+='"secret":'+vv+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface DelProxyResp{
}
function JsonToDelProxyResp(_jsonobj: { [k:string]:any }): DelProxyResp{
	let obj: DelProxyResp={
	}
	return obj
}
export interface GetAppReq{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	project_id: Array<number>|null|undefined;
	g_name: string;
	a_name: string;
	secret: string;
}
function GetAppReqToJson(msg: GetAppReq): string{
	let s: string="{"
	//project_id
	if(msg.project_id==null||msg.project_id==undefined){
		s+='"project_id":null,'
	}else if(msg.project_id.length==0){
		s+='"project_id":[],'
	}else{
		s+='"project_id":['
		for(let element of msg.project_id){
			if(element==null||element==undefined||!Number.isInteger(element)){
				throw 'element in GetAppReq.project_id must be integer'
			}
			if(element>4294967295||element<0){
				throw 'element in GetAppReq.project_id overflow'
			}
			s+=element+','
		}
		s=s.substr(0,s.length-1)+'],'
	}
	//g_name
	if(msg.g_name==null||msg.g_name==undefined){
		throw 'GetAppReq.g_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.g_name)
		s+='"g_name":'+vv+','
	}
	//a_name
	if(msg.a_name==null||msg.a_name==undefined){
		throw 'GetAppReq.a_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.a_name)
		s+='"a_name":'+vv+','
	}
	//secret
	if(msg.secret==null||msg.secret==undefined){
		throw 'GetAppReq.secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.secret)
		s+='"secret":'+vv+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface GetAppResp{
	keys: Map<string,KeyConfigInfo|null|undefined>|null|undefined;
	paths: Map<string,ProxyPathInfo|null|undefined>|null|undefined;
}
function JsonToGetAppResp(jsonobj: { [k:string]:any }): GetAppResp{
	let obj: GetAppResp={
		keys:null,
		paths:null,
	}
	//keys
	if(jsonobj['keys']!=null&&jsonobj['keys']!=undefined){
		if(typeof jsonobj['keys']!='object'){
			throw 'GetAppResp.keys must be Map<string,KeyConfigInfo|null|undefined>|null|undefined'
		}
		for(let key of Object.keys(jsonobj['keys'])){
			let value=jsonobj['keys'][key]
			let k: string=key
			let v: KeyConfigInfo|null|undefined=null
			if(typeof value==null||typeof value==undefined){
				v=null
			}else if(typeof value!='object'){
				throw 'value in GetAppResp.keys must be KeyConfigInfo|null|undefined'
			}else{
				v=JsonToKeyConfigInfo(value)
			}
			if(obj['keys']==undefined){
				obj['keys']=new Map<string,KeyConfigInfo|null|undefined>
			}
			obj['keys'].set(k,v)
		}
	}
	//paths
	if(jsonobj['paths']!=null&&jsonobj['paths']!=undefined){
		if(typeof jsonobj['paths']!='object'){
			throw 'GetAppResp.paths must be Map<string,ProxyPathInfo|null|undefined>|null|undefined'
		}
		for(let key of Object.keys(jsonobj['paths'])){
			let value=jsonobj['paths'][key]
			let k: string=key
			let v: ProxyPathInfo|null|undefined=null
			if(typeof value==null||typeof value==undefined){
				v=null
			}else if(typeof value!='object'){
				throw 'value in GetAppResp.paths must be ProxyPathInfo|null|undefined'
			}else{
				v=JsonToProxyPathInfo(value)
			}
			if(obj['paths']==undefined){
				obj['paths']=new Map<string,ProxyPathInfo|null|undefined>
			}
			obj['paths'].set(k,v)
		}
	}
	return obj
}
export interface GetKeyConfigReq{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	project_id: Array<number>|null|undefined;
	g_name: string;
	a_name: string;
	key: string;//can't contain '.' in key
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	index: number;//0 means return current active config,config's index start from 1
	secret: string;
}
function GetKeyConfigReqToJson(msg: GetKeyConfigReq): string{
	let s: string="{"
	//project_id
	if(msg.project_id==null||msg.project_id==undefined){
		s+='"project_id":null,'
	}else if(msg.project_id.length==0){
		s+='"project_id":[],'
	}else{
		s+='"project_id":['
		for(let element of msg.project_id){
			if(element==null||element==undefined||!Number.isInteger(element)){
				throw 'element in GetKeyConfigReq.project_id must be integer'
			}
			if(element>4294967295||element<0){
				throw 'element in GetKeyConfigReq.project_id overflow'
			}
			s+=element+','
		}
		s=s.substr(0,s.length-1)+'],'
	}
	//g_name
	if(msg.g_name==null||msg.g_name==undefined){
		throw 'GetKeyConfigReq.g_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.g_name)
		s+='"g_name":'+vv+','
	}
	//a_name
	if(msg.a_name==null||msg.a_name==undefined){
		throw 'GetKeyConfigReq.a_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.a_name)
		s+='"a_name":'+vv+','
	}
	//key
	if(msg.key==null||msg.key==undefined){
		throw 'GetKeyConfigReq.key must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.key)
		s+='"key":'+vv+','
	}
	//index
	if(msg.index==null||msg.index==undefined||!Number.isInteger(msg.index)){
		throw 'GetKeyConfigReq.index must be integer'
	}else if(msg.index>4294967295||msg.index<0){
		throw 'GetKeyConfigReq.index overflow'
	}else{
		s+='"index":'+msg.index+','
	}
	//secret
	if(msg.secret==null||msg.secret==undefined){
		throw 'GetKeyConfigReq.secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.secret)
		s+='"secret":'+vv+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface GetKeyConfigResp{
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	cur_index: number;//current active config index,0 means not exist
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	max_index: number;//current max config index,0 means not exist
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	cur_version: number;//current active config version,config's version start from 1
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	this_index: number;//the config data below belong's to which index
	value: string;
	value_type: string;
}
function JsonToGetKeyConfigResp(jsonobj: { [k:string]:any }): GetKeyConfigResp{
	let obj: GetKeyConfigResp={
		cur_index:0,
		max_index:0,
		cur_version:0,
		this_index:0,
		value:'',
		value_type:'',
	}
	//cur_index
	if(jsonobj['cur_index']!=null&&jsonobj['cur_index']!=undefined){
		if(typeof jsonobj['cur_index']!='number'||!Number.isInteger(jsonobj['cur_index'])){
			throw 'GetKeyConfigResp.cur_index must be integer'
		}else if(jsonobj['cur_index']>4294967295||jsonobj['cur_index']<0){
			throw 'GetKeyConfigResp.cur_index overflow'
		}
		obj['cur_index']=jsonobj['cur_index']
	}
	//max_index
	if(jsonobj['max_index']!=null&&jsonobj['max_index']!=undefined){
		if(typeof jsonobj['max_index']!='number'||!Number.isInteger(jsonobj['max_index'])){
			throw 'GetKeyConfigResp.max_index must be integer'
		}else if(jsonobj['max_index']>4294967295||jsonobj['max_index']<0){
			throw 'GetKeyConfigResp.max_index overflow'
		}
		obj['max_index']=jsonobj['max_index']
	}
	//cur_version
	if(jsonobj['cur_version']!=null&&jsonobj['cur_version']!=undefined){
		if(typeof jsonobj['cur_version']!='number'||!Number.isInteger(jsonobj['cur_version'])){
			throw 'GetKeyConfigResp.cur_version must be integer'
		}else if(jsonobj['cur_version']>4294967295||jsonobj['cur_version']<0){
			throw 'GetKeyConfigResp.cur_version overflow'
		}
		obj['cur_version']=jsonobj['cur_version']
	}
	//this_index
	if(jsonobj['this_index']!=null&&jsonobj['this_index']!=undefined){
		if(typeof jsonobj['this_index']!='number'||!Number.isInteger(jsonobj['this_index'])){
			throw 'GetKeyConfigResp.this_index must be integer'
		}else if(jsonobj['this_index']>4294967295||jsonobj['this_index']<0){
			throw 'GetKeyConfigResp.this_index overflow'
		}
		obj['this_index']=jsonobj['this_index']
	}
	//value
	if(jsonobj['value']!=null&&jsonobj['value']!=undefined){
		if(typeof jsonobj['value']!='string'){
			throw 'GetKeyConfigResp.value must be string'
		}
		obj['value']=jsonobj['value']
	}
	//value_type
	if(jsonobj['value_type']!=null&&jsonobj['value_type']!=undefined){
		if(typeof jsonobj['value_type']!='string'){
			throw 'GetKeyConfigResp.value_type must be string'
		}
		obj['value_type']=jsonobj['value_type']
	}
	return obj
}
export interface KeyConfigInfo{
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	cur_index: number;
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	max_index: number;
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	cur_version: number;
	cur_value: string;
	cur_value_type: string;
}
function JsonToKeyConfigInfo(jsonobj: { [k:string]:any }): KeyConfigInfo{
	let obj: KeyConfigInfo={
		cur_index:0,
		max_index:0,
		cur_version:0,
		cur_value:'',
		cur_value_type:'',
	}
	//cur_index
	if(jsonobj['cur_index']!=null&&jsonobj['cur_index']!=undefined){
		if(typeof jsonobj['cur_index']!='number'||!Number.isInteger(jsonobj['cur_index'])){
			throw 'KeyConfigInfo.cur_index must be integer'
		}else if(jsonobj['cur_index']>4294967295||jsonobj['cur_index']<0){
			throw 'KeyConfigInfo.cur_index overflow'
		}
		obj['cur_index']=jsonobj['cur_index']
	}
	//max_index
	if(jsonobj['max_index']!=null&&jsonobj['max_index']!=undefined){
		if(typeof jsonobj['max_index']!='number'||!Number.isInteger(jsonobj['max_index'])){
			throw 'KeyConfigInfo.max_index must be integer'
		}else if(jsonobj['max_index']>4294967295||jsonobj['max_index']<0){
			throw 'KeyConfigInfo.max_index overflow'
		}
		obj['max_index']=jsonobj['max_index']
	}
	//cur_version
	if(jsonobj['cur_version']!=null&&jsonobj['cur_version']!=undefined){
		if(typeof jsonobj['cur_version']!='number'||!Number.isInteger(jsonobj['cur_version'])){
			throw 'KeyConfigInfo.cur_version must be integer'
		}else if(jsonobj['cur_version']>4294967295||jsonobj['cur_version']<0){
			throw 'KeyConfigInfo.cur_version overflow'
		}
		obj['cur_version']=jsonobj['cur_version']
	}
	//cur_value
	if(jsonobj['cur_value']!=null&&jsonobj['cur_value']!=undefined){
		if(typeof jsonobj['cur_value']!='string'){
			throw 'KeyConfigInfo.cur_value must be string'
		}
		obj['cur_value']=jsonobj['cur_value']
	}
	//cur_value_type
	if(jsonobj['cur_value_type']!=null&&jsonobj['cur_value_type']!=undefined){
		if(typeof jsonobj['cur_value_type']!='string'){
			throw 'KeyConfigInfo.cur_value_type must be string'
		}
		obj['cur_value_type']=jsonobj['cur_value_type']
	}
	return obj
}
export interface ProxyPathInfo{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	node_id: Array<number>|null|undefined;
	read: boolean;//need read permission on this node
	write: boolean;//need write permission on this node
	admin: boolean;//need admin permission on this node
}
function JsonToProxyPathInfo(jsonobj: { [k:string]:any }): ProxyPathInfo{
	let obj: ProxyPathInfo={
		node_id:null,
		read:false,
		write:false,
		admin:false,
	}
	//node_id
	if(jsonobj['node_id']!=null&&jsonobj['node_id']!=undefined){
		if(!(jsonobj['node_id'] instanceof Array)){
			throw 'ProxyPathInfo.node_id must be Array<number>|null|undefined'
		}
		for(let element of jsonobj['node_id']){
			if(typeof element!='number'||!Number.isInteger(element)){
				throw 'element in ProxyPathInfo.node_id must be integer'
			}else if(element>4294967295||element<0){
				throw 'element in ProxyPathInfo.node_id overflow'
			}
			if(obj['node_id']==null){
				obj['node_id']=new Array<number>
			}
			obj['node_id'].push(element)
		}
	}
	//read
	if(jsonobj['read']!=null&&jsonobj['read']!=undefined){
		if(typeof jsonobj['read']!='boolean'){
			throw 'ProxyPathInfo.read must be boolean'
		}
		obj['read']=jsonobj['read']
	}
	//write
	if(jsonobj['write']!=null&&jsonobj['write']!=undefined){
		if(typeof jsonobj['write']!='boolean'){
			throw 'ProxyPathInfo.write must be boolean'
		}
		obj['write']=jsonobj['write']
	}
	//admin
	if(jsonobj['admin']!=null&&jsonobj['admin']!=undefined){
		if(typeof jsonobj['admin']!='boolean'){
			throw 'ProxyPathInfo.admin must be boolean'
		}
		obj['admin']=jsonobj['admin']
	}
	return obj
}
export interface ProxyReq{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	project_id: Array<number>|null|undefined;
	g_name: string;
	a_name: string;
	path: string;
	data: string;
}
function ProxyReqToJson(msg: ProxyReq): string{
	let s: string="{"
	//project_id
	if(msg.project_id==null||msg.project_id==undefined){
		s+='"project_id":null,'
	}else if(msg.project_id.length==0){
		s+='"project_id":[],'
	}else{
		s+='"project_id":['
		for(let element of msg.project_id){
			if(element==null||element==undefined||!Number.isInteger(element)){
				throw 'element in ProxyReq.project_id must be integer'
			}
			if(element>4294967295||element<0){
				throw 'element in ProxyReq.project_id overflow'
			}
			s+=element+','
		}
		s=s.substr(0,s.length-1)+'],'
	}
	//g_name
	if(msg.g_name==null||msg.g_name==undefined){
		throw 'ProxyReq.g_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.g_name)
		s+='"g_name":'+vv+','
	}
	//a_name
	if(msg.a_name==null||msg.a_name==undefined){
		throw 'ProxyReq.a_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.a_name)
		s+='"a_name":'+vv+','
	}
	//path
	if(msg.path==null||msg.path==undefined){
		throw 'ProxyReq.path must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.path)
		s+='"path":'+vv+','
	}
	//data
	if(msg.data==null||msg.data==undefined){
		throw 'ProxyReq.data must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.data)
		s+='"data":'+vv+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface ProxyResp{
	data: string;
}
function JsonToProxyResp(jsonobj: { [k:string]:any }): ProxyResp{
	let obj: ProxyResp={
		data:'',
	}
	//data
	if(jsonobj['data']!=null&&jsonobj['data']!=undefined){
		if(typeof jsonobj['data']!='string'){
			throw 'ProxyResp.data must be string'
		}
		obj['data']=jsonobj['data']
	}
	return obj
}
export interface RollbackReq{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	project_id: Array<number>|null|undefined;
	g_name: string;
	a_name: string;
	key: string;//can't contain '.' in key
	secret: string;
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	index: number;
}
function RollbackReqToJson(msg: RollbackReq): string{
	let s: string="{"
	//project_id
	if(msg.project_id==null||msg.project_id==undefined){
		s+='"project_id":null,'
	}else if(msg.project_id.length==0){
		s+='"project_id":[],'
	}else{
		s+='"project_id":['
		for(let element of msg.project_id){
			if(element==null||element==undefined||!Number.isInteger(element)){
				throw 'element in RollbackReq.project_id must be integer'
			}
			if(element>4294967295||element<0){
				throw 'element in RollbackReq.project_id overflow'
			}
			s+=element+','
		}
		s=s.substr(0,s.length-1)+'],'
	}
	//g_name
	if(msg.g_name==null||msg.g_name==undefined){
		throw 'RollbackReq.g_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.g_name)
		s+='"g_name":'+vv+','
	}
	//a_name
	if(msg.a_name==null||msg.a_name==undefined){
		throw 'RollbackReq.a_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.a_name)
		s+='"a_name":'+vv+','
	}
	//key
	if(msg.key==null||msg.key==undefined){
		throw 'RollbackReq.key must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.key)
		s+='"key":'+vv+','
	}
	//secret
	if(msg.secret==null||msg.secret==undefined){
		throw 'RollbackReq.secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.secret)
		s+='"secret":'+vv+','
	}
	//index
	if(msg.index==null||msg.index==undefined||!Number.isInteger(msg.index)){
		throw 'RollbackReq.index must be integer'
	}else if(msg.index>4294967295||msg.index<0){
		throw 'RollbackReq.index overflow'
	}else{
		s+='"index":'+msg.index+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface RollbackResp{
}
function JsonToRollbackResp(_jsonobj: { [k:string]:any }): RollbackResp{
	let obj: RollbackResp={
	}
	return obj
}
export interface SetKeyConfigReq{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	project_id: Array<number>|null|undefined;
	g_name: string;
	a_name: string;
	key: string;//can't contain '.' in key
	value: string;
	value_type: string;
	secret: string;
	new_key: boolean;
}
function SetKeyConfigReqToJson(msg: SetKeyConfigReq): string{
	let s: string="{"
	//project_id
	if(msg.project_id==null||msg.project_id==undefined){
		s+='"project_id":null,'
	}else if(msg.project_id.length==0){
		s+='"project_id":[],'
	}else{
		s+='"project_id":['
		for(let element of msg.project_id){
			if(element==null||element==undefined||!Number.isInteger(element)){
				throw 'element in SetKeyConfigReq.project_id must be integer'
			}
			if(element>4294967295||element<0){
				throw 'element in SetKeyConfigReq.project_id overflow'
			}
			s+=element+','
		}
		s=s.substr(0,s.length-1)+'],'
	}
	//g_name
	if(msg.g_name==null||msg.g_name==undefined){
		throw 'SetKeyConfigReq.g_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.g_name)
		s+='"g_name":'+vv+','
	}
	//a_name
	if(msg.a_name==null||msg.a_name==undefined){
		throw 'SetKeyConfigReq.a_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.a_name)
		s+='"a_name":'+vv+','
	}
	//key
	if(msg.key==null||msg.key==undefined){
		throw 'SetKeyConfigReq.key must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.key)
		s+='"key":'+vv+','
	}
	//value
	if(msg.value==null||msg.value==undefined){
		throw 'SetKeyConfigReq.value must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.value)
		s+='"value":'+vv+','
	}
	//value_type
	if(msg.value_type==null||msg.value_type==undefined){
		throw 'SetKeyConfigReq.value_type must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.value_type)
		s+='"value_type":'+vv+','
	}
	//secret
	if(msg.secret==null||msg.secret==undefined){
		throw 'SetKeyConfigReq.secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.secret)
		s+='"secret":'+vv+','
	}
	//new_key
	if(msg.new_key==null||msg.new_key==undefined){
		throw 'SetKeyConfigReq.new_key must be boolean'
	}else{
		s+='"new_key":'+msg.new_key+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface SetKeyConfigResp{
}
function JsonToSetKeyConfigResp(_jsonobj: { [k:string]:any }): SetKeyConfigResp{
	let obj: SetKeyConfigResp={
	}
	return obj
}
export interface SetProxyReq{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	project_id: Array<number>|null|undefined;
	g_name: string;
	a_name: string;
	path: string;
	read: boolean;//need read permission on this node
	write: boolean;//need write permission on this node
	admin: boolean;//need admin permission on this node
	secret: string;
	new_path: boolean;
}
function SetProxyReqToJson(msg: SetProxyReq): string{
	let s: string="{"
	//project_id
	if(msg.project_id==null||msg.project_id==undefined){
		s+='"project_id":null,'
	}else if(msg.project_id.length==0){
		s+='"project_id":[],'
	}else{
		s+='"project_id":['
		for(let element of msg.project_id){
			if(element==null||element==undefined||!Number.isInteger(element)){
				throw 'element in SetProxyReq.project_id must be integer'
			}
			if(element>4294967295||element<0){
				throw 'element in SetProxyReq.project_id overflow'
			}
			s+=element+','
		}
		s=s.substr(0,s.length-1)+'],'
	}
	//g_name
	if(msg.g_name==null||msg.g_name==undefined){
		throw 'SetProxyReq.g_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.g_name)
		s+='"g_name":'+vv+','
	}
	//a_name
	if(msg.a_name==null||msg.a_name==undefined){
		throw 'SetProxyReq.a_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.a_name)
		s+='"a_name":'+vv+','
	}
	//path
	if(msg.path==null||msg.path==undefined){
		throw 'SetProxyReq.path must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.path)
		s+='"path":'+vv+','
	}
	//read
	if(msg.read==null||msg.read==undefined){
		throw 'SetProxyReq.read must be boolean'
	}else{
		s+='"read":'+msg.read+','
	}
	//write
	if(msg.write==null||msg.write==undefined){
		throw 'SetProxyReq.write must be boolean'
	}else{
		s+='"write":'+msg.write+','
	}
	//admin
	if(msg.admin==null||msg.admin==undefined){
		throw 'SetProxyReq.admin must be boolean'
	}else{
		s+='"admin":'+msg.admin+','
	}
	//secret
	if(msg.secret==null||msg.secret==undefined){
		throw 'SetProxyReq.secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.secret)
		s+='"secret":'+vv+','
	}
	//new_path
	if(msg.new_path==null||msg.new_path==undefined){
		throw 'SetProxyReq.new_path must be boolean'
	}else{
		s+='"new_path":'+msg.new_path+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface SetProxyResp{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	node_id: Array<number>|null|undefined;
}
function JsonToSetProxyResp(jsonobj: { [k:string]:any }): SetProxyResp{
	let obj: SetProxyResp={
		node_id:null,
	}
	//node_id
	if(jsonobj['node_id']!=null&&jsonobj['node_id']!=undefined){
		if(!(jsonobj['node_id'] instanceof Array)){
			throw 'SetProxyResp.node_id must be Array<number>|null|undefined'
		}
		for(let element of jsonobj['node_id']){
			if(typeof element!='number'||!Number.isInteger(element)){
				throw 'element in SetProxyResp.node_id must be integer'
			}else if(element>4294967295||element<0){
				throw 'element in SetProxyResp.node_id overflow'
			}
			if(obj['node_id']==null){
				obj['node_id']=new Array<number>
			}
			obj['node_id'].push(element)
		}
	}
	return obj
}
export interface UpdateAppSecretReq{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	project_id: Array<number>|null|undefined;
	g_name: string;
	a_name: string;
	old_secret: string;
	new_secret: string;
}
function UpdateAppSecretReqToJson(msg: UpdateAppSecretReq): string{
	let s: string="{"
	//project_id
	if(msg.project_id==null||msg.project_id==undefined){
		s+='"project_id":null,'
	}else if(msg.project_id.length==0){
		s+='"project_id":[],'
	}else{
		s+='"project_id":['
		for(let element of msg.project_id){
			if(element==null||element==undefined||!Number.isInteger(element)){
				throw 'element in UpdateAppSecretReq.project_id must be integer'
			}
			if(element>4294967295||element<0){
				throw 'element in UpdateAppSecretReq.project_id overflow'
			}
			s+=element+','
		}
		s=s.substr(0,s.length-1)+'],'
	}
	//g_name
	if(msg.g_name==null||msg.g_name==undefined){
		throw 'UpdateAppSecretReq.g_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.g_name)
		s+='"g_name":'+vv+','
	}
	//a_name
	if(msg.a_name==null||msg.a_name==undefined){
		throw 'UpdateAppSecretReq.a_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.a_name)
		s+='"a_name":'+vv+','
	}
	//old_secret
	if(msg.old_secret==null||msg.old_secret==undefined){
		throw 'UpdateAppSecretReq.old_secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.old_secret)
		s+='"old_secret":'+vv+','
	}
	//new_secret
	if(msg.new_secret==null||msg.new_secret==undefined){
		throw 'UpdateAppSecretReq.new_secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.new_secret)
		s+='"new_secret":'+vv+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface UpdateAppSecretResp{
}
function JsonToUpdateAppSecretResp(_jsonobj: { [k:string]:any }): UpdateAppSecretResp{
	let obj: UpdateAppSecretResp={
	}
	return obj
}
export interface WatchData{
	key: string;
	value: string;
	value_type: string;
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	version: number;
}
function JsonToWatchData(jsonobj: { [k:string]:any }): WatchData{
	let obj: WatchData={
		key:'',
		value:'',
		value_type:'',
		version:0,
	}
	//key
	if(jsonobj['key']!=null&&jsonobj['key']!=undefined){
		if(typeof jsonobj['key']!='string'){
			throw 'WatchData.key must be string'
		}
		obj['key']=jsonobj['key']
	}
	//value
	if(jsonobj['value']!=null&&jsonobj['value']!=undefined){
		if(typeof jsonobj['value']!='string'){
			throw 'WatchData.value must be string'
		}
		obj['value']=jsonobj['value']
	}
	//value_type
	if(jsonobj['value_type']!=null&&jsonobj['value_type']!=undefined){
		if(typeof jsonobj['value_type']!='string'){
			throw 'WatchData.value_type must be string'
		}
		obj['value_type']=jsonobj['value_type']
	}
	//version
	if(jsonobj['version']!=null&&jsonobj['version']!=undefined){
		if(typeof jsonobj['version']!='number'||!Number.isInteger(jsonobj['version'])){
			throw 'WatchData.version must be integer'
		}else if(jsonobj['version']>4294967295||jsonobj['version']<0){
			throw 'WatchData.version overflow'
		}
		obj['version']=jsonobj['version']
	}
	return obj
}
export interface WatchReq{
	project_name: string;
	g_name: string;
	a_name: string;
	//map's key is config's keyname,map's value is config's cur version
	//if cur version == 0 means return current active config
	//if all cur version is the newest,the request will block until a new version come
	//if some keys' version is the newest,and some keys' version is old,then the keys with old version will return newest version and datas,the newest's keys will only return version
	//Warning!!!map's value's type is uint32,be careful of sign(+) and overflow
	keys: Map<string,number>|null|undefined;//can't contain '.' in key
}
function WatchReqToJson(msg: WatchReq): string{
	let s: string="{"
	//project_name
	if(msg.project_name==null||msg.project_name==undefined){
		throw 'WatchReq.project_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.project_name)
		s+='"project_name":'+vv+','
	}
	//g_name
	if(msg.g_name==null||msg.g_name==undefined){
		throw 'WatchReq.g_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.g_name)
		s+='"g_name":'+vv+','
	}
	//a_name
	if(msg.a_name==null||msg.a_name==undefined){
		throw 'WatchReq.a_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.a_name)
		s+='"a_name":'+vv+','
	}
	//keys
	if(msg.keys==null||msg.keys==undefined){
		s+='"keys":null,'
	}else if (msg.keys.size==0){
		s+='"keys":{},'
	}else{
		s+='"keys":{'
		for(let kv of msg.keys.entries()){
			if(kv[0]==null||kv[0]==undefined){
				throw "map's key in WatchReq.keys must be string"
			}
			//transfer the json escape
			let vv=JSON.stringify(kv[0])
			s+=vv+':'
			if(kv[1]==null||kv[1]==undefined||!Number.isInteger(kv[1])){
				throw "map's value in WatchReq.keys must be integer"
			}else if(kv[1]>4294967295||kv[1]<0){
				throw "map's value in WatchReq.keys overflow"
			}
			s+=kv[1]+','
		}
		s=s.substr(0,s.length-1)+'},'
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface WatchResp{
	datas: Map<string,WatchData|null|undefined>|null|undefined;
}
function JsonToWatchResp(jsonobj: { [k:string]:any }): WatchResp{
	let obj: WatchResp={
		datas:null,
	}
	//datas
	if(jsonobj['datas']!=null&&jsonobj['datas']!=undefined){
		if(typeof jsonobj['datas']!='object'){
			throw 'WatchResp.datas must be Map<string,WatchData|null|undefined>|null|undefined'
		}
		for(let key of Object.keys(jsonobj['datas'])){
			let value=jsonobj['datas'][key]
			let k: string=key
			let v: WatchData|null|undefined=null
			if(typeof value==null||typeof value==undefined){
				v=null
			}else if(typeof value!='object'){
				throw 'value in WatchResp.datas must be WatchData|null|undefined'
			}else{
				v=JsonToWatchData(value)
			}
			if(obj['datas']==undefined){
				obj['datas']=new Map<string,WatchData|null|undefined>
			}
			obj['datas'].set(k,v)
		}
	}
	return obj
}
const _WebPathAppGetApp: string ="/admin.app/get_app";
const _WebPathAppCreateApp: string ="/admin.app/create_app";
const _WebPathAppDelApp: string ="/admin.app/del_app";
const _WebPathAppUpdateAppSecret: string ="/admin.app/update_app_secret";
const _WebPathAppDelKey: string ="/admin.app/del_key";
const _WebPathAppGetKeyConfig: string ="/admin.app/get_key_config";
const _WebPathAppSetKeyConfig: string ="/admin.app/set_key_config";
const _WebPathAppRollback: string ="/admin.app/rollback";
const _WebPathAppWatch: string ="/admin.app/watch";
const _WebPathAppSetProxy: string ="/admin.app/set_proxy";
const _WebPathAppDelProxy: string ="/admin.app/del_proxy";
const _WebPathAppProxy: string ="/admin.app/proxy";
//ToC means this is used for users
export class AppBrowserClientToC {
	constructor(host: string){
		if(host==null||host==undefined||host.length==0){
			throw "AppBrowserClientToC's host missing"
		}
		this.host=host
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	get_app(header: { [k: string]: string },req: GetAppReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: GetAppResp)=>void){
		if(!Number.isInteger(timeout)){
			errorf({code:-2,msg:'timeout must be integer'})
			return
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let body: string=''
		try{
			body=GetAppReqToJson(req)
		}catch(e){
			errorf({code:-2,msg:''+e})
			return
		}
		let config={
			url:_WebPathAppGetApp,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: body,
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			try{
				let obj:GetAppResp=JsonToGetAppResp(response.data)
				successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'response error'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	create_app(header: { [k: string]: string },req: CreateAppReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: CreateAppResp)=>void){
		if(!Number.isInteger(timeout)){
			errorf({code:-2,msg:'timeout must be integer'})
			return
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let body: string=''
		try{
			body=CreateAppReqToJson(req)
		}catch(e){
			errorf({code:-2,msg:''+e})
			return
		}
		let config={
			url:_WebPathAppCreateApp,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: body,
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			try{
				let obj:CreateAppResp=JsonToCreateAppResp(response.data)
				successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'response error'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	del_app(header: { [k: string]: string },req: DelAppReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: DelAppResp)=>void){
		if(!Number.isInteger(timeout)){
			errorf({code:-2,msg:'timeout must be integer'})
			return
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let body: string=''
		try{
			body=DelAppReqToJson(req)
		}catch(e){
			errorf({code:-2,msg:''+e})
			return
		}
		let config={
			url:_WebPathAppDelApp,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: body,
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			try{
				let obj:DelAppResp=JsonToDelAppResp(response.data)
				successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'response error'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	update_app_secret(header: { [k: string]: string },req: UpdateAppSecretReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: UpdateAppSecretResp)=>void){
		if(!Number.isInteger(timeout)){
			errorf({code:-2,msg:'timeout must be integer'})
			return
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let body: string=''
		try{
			body=UpdateAppSecretReqToJson(req)
		}catch(e){
			errorf({code:-2,msg:''+e})
			return
		}
		let config={
			url:_WebPathAppUpdateAppSecret,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: body,
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			try{
				let obj:UpdateAppSecretResp=JsonToUpdateAppSecretResp(response.data)
				successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'response error'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	del_key(header: { [k: string]: string },req: DelKeyReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: DelKeyResp)=>void){
		if(!Number.isInteger(timeout)){
			errorf({code:-2,msg:'timeout must be integer'})
			return
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let body: string=''
		try{
			body=DelKeyReqToJson(req)
		}catch(e){
			errorf({code:-2,msg:''+e})
			return
		}
		let config={
			url:_WebPathAppDelKey,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: body,
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			try{
				let obj:DelKeyResp=JsonToDelKeyResp(response.data)
				successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'response error'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	get_key_config(header: { [k: string]: string },req: GetKeyConfigReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: GetKeyConfigResp)=>void){
		if(!Number.isInteger(timeout)){
			errorf({code:-2,msg:'timeout must be integer'})
			return
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let body: string=''
		try{
			body=GetKeyConfigReqToJson(req)
		}catch(e){
			errorf({code:-2,msg:''+e})
			return
		}
		let config={
			url:_WebPathAppGetKeyConfig,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: body,
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			try{
				let obj:GetKeyConfigResp=JsonToGetKeyConfigResp(response.data)
				successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'response error'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	set_key_config(header: { [k: string]: string },req: SetKeyConfigReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: SetKeyConfigResp)=>void){
		if(!Number.isInteger(timeout)){
			errorf({code:-2,msg:'timeout must be integer'})
			return
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let body: string=''
		try{
			body=SetKeyConfigReqToJson(req)
		}catch(e){
			errorf({code:-2,msg:''+e})
			return
		}
		let config={
			url:_WebPathAppSetKeyConfig,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: body,
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			try{
				let obj:SetKeyConfigResp=JsonToSetKeyConfigResp(response.data)
				successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'response error'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	rollback(header: { [k: string]: string },req: RollbackReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: RollbackResp)=>void){
		if(!Number.isInteger(timeout)){
			errorf({code:-2,msg:'timeout must be integer'})
			return
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let body: string=''
		try{
			body=RollbackReqToJson(req)
		}catch(e){
			errorf({code:-2,msg:''+e})
			return
		}
		let config={
			url:_WebPathAppRollback,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: body,
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			try{
				let obj:RollbackResp=JsonToRollbackResp(response.data)
				successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'response error'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	watch(header: { [k: string]: string },req: WatchReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: WatchResp)=>void){
		if(!Number.isInteger(timeout)){
			errorf({code:-2,msg:'timeout must be integer'})
			return
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let body: string=''
		try{
			body=WatchReqToJson(req)
		}catch(e){
			errorf({code:-2,msg:''+e})
			return
		}
		let config={
			url:_WebPathAppWatch,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: body,
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			try{
				let obj:WatchResp=JsonToWatchResp(response.data)
				successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'response error'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	set_proxy(header: { [k: string]: string },req: SetProxyReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: SetProxyResp)=>void){
		if(!Number.isInteger(timeout)){
			errorf({code:-2,msg:'timeout must be integer'})
			return
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let body: string=''
		try{
			body=SetProxyReqToJson(req)
		}catch(e){
			errorf({code:-2,msg:''+e})
			return
		}
		let config={
			url:_WebPathAppSetProxy,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: body,
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			try{
				let obj:SetProxyResp=JsonToSetProxyResp(response.data)
				successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'response error'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	del_proxy(header: { [k: string]: string },req: DelProxyReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: DelProxyResp)=>void){
		if(!Number.isInteger(timeout)){
			errorf({code:-2,msg:'timeout must be integer'})
			return
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let body: string=''
		try{
			body=DelProxyReqToJson(req)
		}catch(e){
			errorf({code:-2,msg:''+e})
			return
		}
		let config={
			url:_WebPathAppDelProxy,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: body,
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			try{
				let obj:DelProxyResp=JsonToDelProxyResp(response.data)
				successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'response error'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	proxy(header: { [k: string]: string },req: ProxyReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: ProxyResp)=>void){
		if(!Number.isInteger(timeout)){
			errorf({code:-2,msg:'timeout must be integer'})
			return
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let body: string=''
		try{
			body=ProxyReqToJson(req)
		}catch(e){
			errorf({code:-2,msg:''+e})
			return
		}
		let config={
			url:_WebPathAppProxy,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: body,
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			try{
				let obj:ProxyResp=JsonToProxyResp(response.data)
				successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'response error'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	private host: string
}
