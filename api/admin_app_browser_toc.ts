// Code generated by protoc-gen-browser. DO NOT EDIT.
// version:
// 	protoc-gen-browser v0.0.81<br />
// 	protoc             v4.24.1<br />
// source: api/admin_app.proto<br />

import Axios from "axios";
import Long from "long";

export interface Error{
	code: number;
	msg: string;
}

export interface DelAppReq{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	project_id: Array<number>|null|undefined;
	g_name: string;
	a_name: string;
	secret: string;
}
function DelAppReqToJson(msg: DelAppReq): string{
	let s: string="{"
	//project_id
	if(msg.project_id==null||msg.project_id==undefined){
		s+='"project_id":null,'
	}else if(msg.project_id.length==0){
		s+='"project_id":[],'
	}else{
		s+='"project_id":['
		for(let element of msg.project_id){
			if(element==null||element==undefined||!Number.isInteger(element)){
				throw 'element in DelAppReq.project_id must be integer'
			}
			if(element>4294967295||element<0){
				throw 'element in DelAppReq.project_id overflow'
			}
			s+=element+','
		}
		s=s.substr(0,s.length-1)+'],'
	}
	//g_name
	if(msg.g_name==null||msg.g_name==undefined){
		throw 'DelAppReq.g_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.g_name)
		s+='"g_name":'+vv+','
	}
	//a_name
	if(msg.a_name==null||msg.a_name==undefined){
		throw 'DelAppReq.a_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.a_name)
		s+='"a_name":'+vv+','
	}
	//secret
	if(msg.secret==null||msg.secret==undefined){
		throw 'DelAppReq.secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.secret)
		s+='"secret":'+vv+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface DelAppResp{
}
function JsonToDelAppResp(_jsonobj: { [k:string]:any }): DelAppResp{
	let obj: DelAppResp={
	}
	return obj
}
export interface DelKeyReq{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	project_id: Array<number>|null|undefined;
	g_name: string;
	a_name: string;
	key: string;//can't contain '.' in key
	secret: string;
}
function DelKeyReqToJson(msg: DelKeyReq): string{
	let s: string="{"
	//project_id
	if(msg.project_id==null||msg.project_id==undefined){
		s+='"project_id":null,'
	}else if(msg.project_id.length==0){
		s+='"project_id":[],'
	}else{
		s+='"project_id":['
		for(let element of msg.project_id){
			if(element==null||element==undefined||!Number.isInteger(element)){
				throw 'element in DelKeyReq.project_id must be integer'
			}
			if(element>4294967295||element<0){
				throw 'element in DelKeyReq.project_id overflow'
			}
			s+=element+','
		}
		s=s.substr(0,s.length-1)+'],'
	}
	//g_name
	if(msg.g_name==null||msg.g_name==undefined){
		throw 'DelKeyReq.g_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.g_name)
		s+='"g_name":'+vv+','
	}
	//a_name
	if(msg.a_name==null||msg.a_name==undefined){
		throw 'DelKeyReq.a_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.a_name)
		s+='"a_name":'+vv+','
	}
	//key
	if(msg.key==null||msg.key==undefined){
		throw 'DelKeyReq.key must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.key)
		s+='"key":'+vv+','
	}
	//secret
	if(msg.secret==null||msg.secret==undefined){
		throw 'DelKeyReq.secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.secret)
		s+='"secret":'+vv+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface DelKeyResp{
}
function JsonToDelKeyResp(_jsonobj: { [k:string]:any }): DelKeyResp{
	let obj: DelKeyResp={
	}
	return obj
}
export interface DelProxyReq{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	project_id: Array<number>|null|undefined;
	g_name: string;
	a_name: string;
	path: string;
	secret: string;
}
function DelProxyReqToJson(msg: DelProxyReq): string{
	let s: string="{"
	//project_id
	if(msg.project_id==null||msg.project_id==undefined){
		s+='"project_id":null,'
	}else if(msg.project_id.length==0){
		s+='"project_id":[],'
	}else{
		s+='"project_id":['
		for(let element of msg.project_id){
			if(element==null||element==undefined||!Number.isInteger(element)){
				throw 'element in DelProxyReq.project_id must be integer'
			}
			if(element>4294967295||element<0){
				throw 'element in DelProxyReq.project_id overflow'
			}
			s+=element+','
		}
		s=s.substr(0,s.length-1)+'],'
	}
	//g_name
	if(msg.g_name==null||msg.g_name==undefined){
		throw 'DelProxyReq.g_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.g_name)
		s+='"g_name":'+vv+','
	}
	//a_name
	if(msg.a_name==null||msg.a_name==undefined){
		throw 'DelProxyReq.a_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.a_name)
		s+='"a_name":'+vv+','
	}
	//path
	if(msg.path==null||msg.path==undefined){
		throw 'DelProxyReq.path must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.path)
		s+='"path":'+vv+','
	}
	//secret
	if(msg.secret==null||msg.secret==undefined){
		throw 'DelProxyReq.secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.secret)
		s+='"secret":'+vv+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface DelProxyResp{
}
function JsonToDelProxyResp(_jsonobj: { [k:string]:any }): DelProxyResp{
	let obj: DelProxyResp={
	}
	return obj
}
export interface GetAppReq{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	project_id: Array<number>|null|undefined;
	g_name: string;
	a_name: string;
	secret: string;
}
function GetAppReqToJson(msg: GetAppReq): string{
	let s: string="{"
	//project_id
	if(msg.project_id==null||msg.project_id==undefined){
		s+='"project_id":null,'
	}else if(msg.project_id.length==0){
		s+='"project_id":[],'
	}else{
		s+='"project_id":['
		for(let element of msg.project_id){
			if(element==null||element==undefined||!Number.isInteger(element)){
				throw 'element in GetAppReq.project_id must be integer'
			}
			if(element>4294967295||element<0){
				throw 'element in GetAppReq.project_id overflow'
			}
			s+=element+','
		}
		s=s.substr(0,s.length-1)+'],'
	}
	//g_name
	if(msg.g_name==null||msg.g_name==undefined){
		throw 'GetAppReq.g_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.g_name)
		s+='"g_name":'+vv+','
	}
	//a_name
	if(msg.a_name==null||msg.a_name==undefined){
		throw 'GetAppReq.a_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.a_name)
		s+='"a_name":'+vv+','
	}
	//secret
	if(msg.secret==null||msg.secret==undefined){
		throw 'GetAppReq.secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.secret)
		s+='"secret":'+vv+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface GetAppResp{
	discover_mode: string;//can be one of "kubernetes" / "dns" / "static"
	kubernetes_namespace: string;//when discover_mode == "kubernetes"
	kubernetes_labelselector: string;//when discover_mode == "kubernetes"
	kubernetes_fieldselector: string;//when discover_mode == "kubernetes"
	dns_host: string;//when discover_mode == "dns"
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	dns_interval: number;//when discover_mode == "dns",unit second
	static_addrs: Array<string>|null|undefined;//when discover_mode == "static"
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	crpc_port: number;
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	cgrpc_port: number;
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	web_port: number;
	keys: Map<string,KeyConfigInfo|null|undefined>|null|undefined;
	paths: Map<string,ProxyPathInfo|null|undefined>|null|undefined;
}
function JsonToGetAppResp(jsonobj: { [k:string]:any }): GetAppResp{
	let obj: GetAppResp={
		discover_mode:'',
		kubernetes_namespace:'',
		kubernetes_labelselector:'',
		kubernetes_fieldselector:'',
		dns_host:'',
		dns_interval:0,
		static_addrs:null,
		crpc_port:0,
		cgrpc_port:0,
		web_port:0,
		keys:null,
		paths:null,
	}
	//discover_mode
	if(jsonobj['discover_mode']!=null&&jsonobj['discover_mode']!=undefined){
		if(typeof jsonobj['discover_mode']!='string'){
			throw 'GetAppResp.discover_mode must be string'
		}
		obj['discover_mode']=jsonobj['discover_mode']
	}
	//kubernetes_namespace
	if(jsonobj['kubernetes_namespace']!=null&&jsonobj['kubernetes_namespace']!=undefined){
		if(typeof jsonobj['kubernetes_namespace']!='string'){
			throw 'GetAppResp.kubernetes_namespace must be string'
		}
		obj['kubernetes_namespace']=jsonobj['kubernetes_namespace']
	}
	//kubernetes_labelselector
	if(jsonobj['kubernetes_labelselector']!=null&&jsonobj['kubernetes_labelselector']!=undefined){
		if(typeof jsonobj['kubernetes_labelselector']!='string'){
			throw 'GetAppResp.kubernetes_labelselector must be string'
		}
		obj['kubernetes_labelselector']=jsonobj['kubernetes_labelselector']
	}
	//kubernetes_fieldselector
	if(jsonobj['kubernetes_fieldselector']!=null&&jsonobj['kubernetes_fieldselector']!=undefined){
		if(typeof jsonobj['kubernetes_fieldselector']!='string'){
			throw 'GetAppResp.kubernetes_fieldselector must be string'
		}
		obj['kubernetes_fieldselector']=jsonobj['kubernetes_fieldselector']
	}
	//dns_host
	if(jsonobj['dns_host']!=null&&jsonobj['dns_host']!=undefined){
		if(typeof jsonobj['dns_host']!='string'){
			throw 'GetAppResp.dns_host must be string'
		}
		obj['dns_host']=jsonobj['dns_host']
	}
	//dns_interval
	if(jsonobj['dns_interval']!=null&&jsonobj['dns_interval']!=undefined){
		if(typeof jsonobj['dns_interval']!='number'||!Number.isInteger(jsonobj['dns_interval'])){
			throw 'GetAppResp.dns_interval must be integer'
		}else if(jsonobj['dns_interval']>4294967295||jsonobj['dns_interval']<0){
			throw 'GetAppResp.dns_interval overflow'
		}
		obj['dns_interval']=jsonobj['dns_interval']
	}
	//static_addrs
	if(jsonobj['static_addrs']!=null&&jsonobj['static_addrs']!=undefined){
		if(!(jsonobj['static_addrs'] instanceof Array)){
			throw 'GetAppResp.static_addrs must be Array<string>|null|undefined'
		}
		for(let element of jsonobj['static_addrs']){
			if(typeof element!='string'){
				throw 'element in GetAppResp.static_addrs must be string'
			}
			if(obj['static_addrs']==null){
				obj['static_addrs']=new Array<string>
			}
			obj['static_addrs'].push(element)
		}
	}
	//crpc_port
	if(jsonobj['crpc_port']!=null&&jsonobj['crpc_port']!=undefined){
		if(typeof jsonobj['crpc_port']!='number'||!Number.isInteger(jsonobj['crpc_port'])){
			throw 'GetAppResp.crpc_port must be integer'
		}else if(jsonobj['crpc_port']>4294967295||jsonobj['crpc_port']<0){
			throw 'GetAppResp.crpc_port overflow'
		}
		obj['crpc_port']=jsonobj['crpc_port']
	}
	//cgrpc_port
	if(jsonobj['cgrpc_port']!=null&&jsonobj['cgrpc_port']!=undefined){
		if(typeof jsonobj['cgrpc_port']!='number'||!Number.isInteger(jsonobj['cgrpc_port'])){
			throw 'GetAppResp.cgrpc_port must be integer'
		}else if(jsonobj['cgrpc_port']>4294967295||jsonobj['cgrpc_port']<0){
			throw 'GetAppResp.cgrpc_port overflow'
		}
		obj['cgrpc_port']=jsonobj['cgrpc_port']
	}
	//web_port
	if(jsonobj['web_port']!=null&&jsonobj['web_port']!=undefined){
		if(typeof jsonobj['web_port']!='number'||!Number.isInteger(jsonobj['web_port'])){
			throw 'GetAppResp.web_port must be integer'
		}else if(jsonobj['web_port']>4294967295||jsonobj['web_port']<0){
			throw 'GetAppResp.web_port overflow'
		}
		obj['web_port']=jsonobj['web_port']
	}
	//keys
	if(jsonobj['keys']!=null&&jsonobj['keys']!=undefined){
		if(typeof jsonobj['keys']!='object'){
			throw 'GetAppResp.keys must be Map<string,KeyConfigInfo|null|undefined>|null|undefined'
		}
		for(let key of Object.keys(jsonobj['keys'])){
			let value=jsonobj['keys'][key]
			let k: string=key
			let v: KeyConfigInfo|null|undefined=null
			if(typeof value==null||typeof value==undefined){
				v=null
			}else if(typeof value!='object'){
				throw 'value in GetAppResp.keys must be KeyConfigInfo|null|undefined'
			}else{
				v=JsonToKeyConfigInfo(value)
			}
			if(obj['keys']==undefined){
				obj['keys']=new Map<string,KeyConfigInfo|null|undefined>
			}
			obj['keys'].set(k,v)
		}
	}
	//paths
	if(jsonobj['paths']!=null&&jsonobj['paths']!=undefined){
		if(typeof jsonobj['paths']!='object'){
			throw 'GetAppResp.paths must be Map<string,ProxyPathInfo|null|undefined>|null|undefined'
		}
		for(let key of Object.keys(jsonobj['paths'])){
			let value=jsonobj['paths'][key]
			let k: string=key
			let v: ProxyPathInfo|null|undefined=null
			if(typeof value==null||typeof value==undefined){
				v=null
			}else if(typeof value!='object'){
				throw 'value in GetAppResp.paths must be ProxyPathInfo|null|undefined'
			}else{
				v=JsonToProxyPathInfo(value)
			}
			if(obj['paths']==undefined){
				obj['paths']=new Map<string,ProxyPathInfo|null|undefined>
			}
			obj['paths'].set(k,v)
		}
	}
	return obj
}
export interface GetInstanceInfoReq{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	project_id: Array<number>|null|undefined;
	g_name: string;
	a_name: string;
	secret: string;
	addr: string;
}
function GetInstanceInfoReqToJson(msg: GetInstanceInfoReq): string{
	let s: string="{"
	//project_id
	if(msg.project_id==null||msg.project_id==undefined){
		s+='"project_id":null,'
	}else if(msg.project_id.length==0){
		s+='"project_id":[],'
	}else{
		s+='"project_id":['
		for(let element of msg.project_id){
			if(element==null||element==undefined||!Number.isInteger(element)){
				throw 'element in GetInstanceInfoReq.project_id must be integer'
			}
			if(element>4294967295||element<0){
				throw 'element in GetInstanceInfoReq.project_id overflow'
			}
			s+=element+','
		}
		s=s.substr(0,s.length-1)+'],'
	}
	//g_name
	if(msg.g_name==null||msg.g_name==undefined){
		throw 'GetInstanceInfoReq.g_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.g_name)
		s+='"g_name":'+vv+','
	}
	//a_name
	if(msg.a_name==null||msg.a_name==undefined){
		throw 'GetInstanceInfoReq.a_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.a_name)
		s+='"a_name":'+vv+','
	}
	//secret
	if(msg.secret==null||msg.secret==undefined){
		throw 'GetInstanceInfoReq.secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.secret)
		s+='"secret":'+vv+','
	}
	//addr
	if(msg.addr==null||msg.addr==undefined){
		throw 'GetInstanceInfoReq.addr must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.addr)
		s+='"addr":'+vv+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface GetInstanceInfoResp{
	info: InstanceInfo|null|undefined;
}
function JsonToGetInstanceInfoResp(jsonobj: { [k:string]:any }): GetInstanceInfoResp{
	let obj: GetInstanceInfoResp={
		info:null,
	}
	//info
	if(jsonobj['info']!=null&&jsonobj['info']!=undefined){
		if(typeof jsonobj['info']!='object'){
			throw 'GetInstanceInfoResp.info must be InstanceInfo'
		}
		obj['info']=JsonToInstanceInfo(jsonobj['info'])
	}
	return obj
}
export interface GetInstancesReq{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	project_id: Array<number>|null|undefined;
	g_name: string;
	a_name: string;
	secret: string;
	with_info: boolean;
}
function GetInstancesReqToJson(msg: GetInstancesReq): string{
	let s: string="{"
	//project_id
	if(msg.project_id==null||msg.project_id==undefined){
		s+='"project_id":null,'
	}else if(msg.project_id.length==0){
		s+='"project_id":[],'
	}else{
		s+='"project_id":['
		for(let element of msg.project_id){
			if(element==null||element==undefined||!Number.isInteger(element)){
				throw 'element in GetInstancesReq.project_id must be integer'
			}
			if(element>4294967295||element<0){
				throw 'element in GetInstancesReq.project_id overflow'
			}
			s+=element+','
		}
		s=s.substr(0,s.length-1)+'],'
	}
	//g_name
	if(msg.g_name==null||msg.g_name==undefined){
		throw 'GetInstancesReq.g_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.g_name)
		s+='"g_name":'+vv+','
	}
	//a_name
	if(msg.a_name==null||msg.a_name==undefined){
		throw 'GetInstancesReq.a_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.a_name)
		s+='"a_name":'+vv+','
	}
	//secret
	if(msg.secret==null||msg.secret==undefined){
		throw 'GetInstancesReq.secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.secret)
		s+='"secret":'+vv+','
	}
	//with_info
	if(msg.with_info==null||msg.with_info==undefined){
		throw 'GetInstancesReq.with_info must be boolean'
	}else{
		s+='"with_info":'+msg.with_info+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface GetInstancesResp{
	instances: Map<string,InstanceInfo|null|undefined>|null|undefined;//key addr,value info,if with_info is false,value is empty
}
function JsonToGetInstancesResp(jsonobj: { [k:string]:any }): GetInstancesResp{
	let obj: GetInstancesResp={
		instances:null,
	}
	//instances
	if(jsonobj['instances']!=null&&jsonobj['instances']!=undefined){
		if(typeof jsonobj['instances']!='object'){
			throw 'GetInstancesResp.instances must be Map<string,InstanceInfo|null|undefined>|null|undefined'
		}
		for(let key of Object.keys(jsonobj['instances'])){
			let value=jsonobj['instances'][key]
			let k: string=key
			let v: InstanceInfo|null|undefined=null
			if(typeof value==null||typeof value==undefined){
				v=null
			}else if(typeof value!='object'){
				throw 'value in GetInstancesResp.instances must be InstanceInfo|null|undefined'
			}else{
				v=JsonToInstanceInfo(value)
			}
			if(obj['instances']==undefined){
				obj['instances']=new Map<string,InstanceInfo|null|undefined>
			}
			obj['instances'].set(k,v)
		}
	}
	return obj
}
export interface GetKeyConfigReq{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	project_id: Array<number>|null|undefined;
	g_name: string;
	a_name: string;
	key: string;//can't contain '.' in key
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	index: number;//0 means return current active config,config's index start from 1
	secret: string;
}
function GetKeyConfigReqToJson(msg: GetKeyConfigReq): string{
	let s: string="{"
	//project_id
	if(msg.project_id==null||msg.project_id==undefined){
		s+='"project_id":null,'
	}else if(msg.project_id.length==0){
		s+='"project_id":[],'
	}else{
		s+='"project_id":['
		for(let element of msg.project_id){
			if(element==null||element==undefined||!Number.isInteger(element)){
				throw 'element in GetKeyConfigReq.project_id must be integer'
			}
			if(element>4294967295||element<0){
				throw 'element in GetKeyConfigReq.project_id overflow'
			}
			s+=element+','
		}
		s=s.substr(0,s.length-1)+'],'
	}
	//g_name
	if(msg.g_name==null||msg.g_name==undefined){
		throw 'GetKeyConfigReq.g_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.g_name)
		s+='"g_name":'+vv+','
	}
	//a_name
	if(msg.a_name==null||msg.a_name==undefined){
		throw 'GetKeyConfigReq.a_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.a_name)
		s+='"a_name":'+vv+','
	}
	//key
	if(msg.key==null||msg.key==undefined){
		throw 'GetKeyConfigReq.key must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.key)
		s+='"key":'+vv+','
	}
	//index
	if(msg.index==null||msg.index==undefined||!Number.isInteger(msg.index)){
		throw 'GetKeyConfigReq.index must be integer'
	}else if(msg.index>4294967295||msg.index<0){
		throw 'GetKeyConfigReq.index overflow'
	}else{
		s+='"index":'+msg.index+','
	}
	//secret
	if(msg.secret==null||msg.secret==undefined){
		throw 'GetKeyConfigReq.secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.secret)
		s+='"secret":'+vv+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface GetKeyConfigResp{
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	cur_index: number;//current active config index,0 means not exist
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	max_index: number;//current max config index,0 means not exist
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	cur_version: number;//current active config version,config's version start from 1
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	this_index: number;//the config data below belong's to which index
	value: string;
	value_type: string;
}
function JsonToGetKeyConfigResp(jsonobj: { [k:string]:any }): GetKeyConfigResp{
	let obj: GetKeyConfigResp={
		cur_index:0,
		max_index:0,
		cur_version:0,
		this_index:0,
		value:'',
		value_type:'',
	}
	//cur_index
	if(jsonobj['cur_index']!=null&&jsonobj['cur_index']!=undefined){
		if(typeof jsonobj['cur_index']!='number'||!Number.isInteger(jsonobj['cur_index'])){
			throw 'GetKeyConfigResp.cur_index must be integer'
		}else if(jsonobj['cur_index']>4294967295||jsonobj['cur_index']<0){
			throw 'GetKeyConfigResp.cur_index overflow'
		}
		obj['cur_index']=jsonobj['cur_index']
	}
	//max_index
	if(jsonobj['max_index']!=null&&jsonobj['max_index']!=undefined){
		if(typeof jsonobj['max_index']!='number'||!Number.isInteger(jsonobj['max_index'])){
			throw 'GetKeyConfigResp.max_index must be integer'
		}else if(jsonobj['max_index']>4294967295||jsonobj['max_index']<0){
			throw 'GetKeyConfigResp.max_index overflow'
		}
		obj['max_index']=jsonobj['max_index']
	}
	//cur_version
	if(jsonobj['cur_version']!=null&&jsonobj['cur_version']!=undefined){
		if(typeof jsonobj['cur_version']!='number'||!Number.isInteger(jsonobj['cur_version'])){
			throw 'GetKeyConfigResp.cur_version must be integer'
		}else if(jsonobj['cur_version']>4294967295||jsonobj['cur_version']<0){
			throw 'GetKeyConfigResp.cur_version overflow'
		}
		obj['cur_version']=jsonobj['cur_version']
	}
	//this_index
	if(jsonobj['this_index']!=null&&jsonobj['this_index']!=undefined){
		if(typeof jsonobj['this_index']!='number'||!Number.isInteger(jsonobj['this_index'])){
			throw 'GetKeyConfigResp.this_index must be integer'
		}else if(jsonobj['this_index']>4294967295||jsonobj['this_index']<0){
			throw 'GetKeyConfigResp.this_index overflow'
		}
		obj['this_index']=jsonobj['this_index']
	}
	//value
	if(jsonobj['value']!=null&&jsonobj['value']!=undefined){
		if(typeof jsonobj['value']!='string'){
			throw 'GetKeyConfigResp.value must be string'
		}
		obj['value']=jsonobj['value']
	}
	//value_type
	if(jsonobj['value_type']!=null&&jsonobj['value_type']!=undefined){
		if(typeof jsonobj['value_type']!='string'){
			throw 'GetKeyConfigResp.value_type must be string'
		}
		obj['value_type']=jsonobj['value_type']
	}
	return obj
}
export interface InstanceInfo{
	name: string;
	//Warning!!!Type is uint64,be careful of sign(+)
	total_mem: Long;
	//Warning!!!Type is uint64,be careful of sign(+)
	cur_mem_usage: Long;
	cpu_num: number;
	cur_cpu_usage: number;
}
function JsonToInstanceInfo(jsonobj: { [k:string]:any }): InstanceInfo{
	let obj: InstanceInfo={
		name:'',
		total_mem:Long.ZERO,
		cur_mem_usage:Long.ZERO,
		cpu_num:0,
		cur_cpu_usage:0,
	}
	//name
	if(jsonobj['name']!=null&&jsonobj['name']!=undefined){
		if(typeof jsonobj['name']!='string'){
			throw 'InstanceInfo.name must be string'
		}
		obj['name']=jsonobj['name']
	}
	//total_mem
	if(jsonobj['total_mem']!=null&&jsonobj['total_mem']!=undefined){
		if(typeof jsonobj['total_mem']=='number'){
			if(!Number.isInteger(jsonobj['total_mem'])){
				throw 'InstanceInfo.total_mem must be integer'
			}
			if(jsonobj['total_mem']<0){
				throw 'InstanceInfo.total_mem overflow'
			}
			let tmp: Long=Long.ZERO
			try{
				tmp=Long.fromNumber(jsonobj['total_mem'],true)
			}catch(e){
				throw 'InstanceInfo.total_mem must be integer'
			}
			obj['total_mem']=tmp
		}else if(typeof jsonobj['total_mem']=='string'){
			let tmp:Long=Long.ZERO
			try{
				tmp=Long.fromString(jsonobj['total_mem'],true)
			}catch(e){
				throw 'InstanceInfo.total_mem must be integer'
			}
			if(tmp.toString()!=jsonobj['total_mem']){
				throw 'InstanceInfo.total_mem overflow'
			}
			obj['total_mem']=tmp
		}else{
			throw 'format wrong!InstanceInfo.total_mem must be integer'
		}
	}
	//cur_mem_usage
	if(jsonobj['cur_mem_usage']!=null&&jsonobj['cur_mem_usage']!=undefined){
		if(typeof jsonobj['cur_mem_usage']=='number'){
			if(!Number.isInteger(jsonobj['cur_mem_usage'])){
				throw 'InstanceInfo.cur_mem_usage must be integer'
			}
			if(jsonobj['cur_mem_usage']<0){
				throw 'InstanceInfo.cur_mem_usage overflow'
			}
			let tmp: Long=Long.ZERO
			try{
				tmp=Long.fromNumber(jsonobj['cur_mem_usage'],true)
			}catch(e){
				throw 'InstanceInfo.cur_mem_usage must be integer'
			}
			obj['cur_mem_usage']=tmp
		}else if(typeof jsonobj['cur_mem_usage']=='string'){
			let tmp:Long=Long.ZERO
			try{
				tmp=Long.fromString(jsonobj['cur_mem_usage'],true)
			}catch(e){
				throw 'InstanceInfo.cur_mem_usage must be integer'
			}
			if(tmp.toString()!=jsonobj['cur_mem_usage']){
				throw 'InstanceInfo.cur_mem_usage overflow'
			}
			obj['cur_mem_usage']=tmp
		}else{
			throw 'format wrong!InstanceInfo.cur_mem_usage must be integer'
		}
	}
	//cpu_num
	if(jsonobj['cpu_num']!=null&&jsonobj['cpu_num']!=undefined){
		if(typeof jsonobj['cpu_num']!='number'){
			throw 'InstanceInfo.cpu_num must be number'
		}
		obj['cpu_num']=jsonobj['cpu_num']
	}
	//cur_cpu_usage
	if(jsonobj['cur_cpu_usage']!=null&&jsonobj['cur_cpu_usage']!=undefined){
		if(typeof jsonobj['cur_cpu_usage']!='number'){
			throw 'InstanceInfo.cur_cpu_usage must be number'
		}
		obj['cur_cpu_usage']=jsonobj['cur_cpu_usage']
	}
	return obj
}
export interface KeyConfigInfo{
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	cur_index: number;
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	max_index: number;
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	cur_version: number;
	cur_value: string;
	cur_value_type: string;
}
function JsonToKeyConfigInfo(jsonobj: { [k:string]:any }): KeyConfigInfo{
	let obj: KeyConfigInfo={
		cur_index:0,
		max_index:0,
		cur_version:0,
		cur_value:'',
		cur_value_type:'',
	}
	//cur_index
	if(jsonobj['cur_index']!=null&&jsonobj['cur_index']!=undefined){
		if(typeof jsonobj['cur_index']!='number'||!Number.isInteger(jsonobj['cur_index'])){
			throw 'KeyConfigInfo.cur_index must be integer'
		}else if(jsonobj['cur_index']>4294967295||jsonobj['cur_index']<0){
			throw 'KeyConfigInfo.cur_index overflow'
		}
		obj['cur_index']=jsonobj['cur_index']
	}
	//max_index
	if(jsonobj['max_index']!=null&&jsonobj['max_index']!=undefined){
		if(typeof jsonobj['max_index']!='number'||!Number.isInteger(jsonobj['max_index'])){
			throw 'KeyConfigInfo.max_index must be integer'
		}else if(jsonobj['max_index']>4294967295||jsonobj['max_index']<0){
			throw 'KeyConfigInfo.max_index overflow'
		}
		obj['max_index']=jsonobj['max_index']
	}
	//cur_version
	if(jsonobj['cur_version']!=null&&jsonobj['cur_version']!=undefined){
		if(typeof jsonobj['cur_version']!='number'||!Number.isInteger(jsonobj['cur_version'])){
			throw 'KeyConfigInfo.cur_version must be integer'
		}else if(jsonobj['cur_version']>4294967295||jsonobj['cur_version']<0){
			throw 'KeyConfigInfo.cur_version overflow'
		}
		obj['cur_version']=jsonobj['cur_version']
	}
	//cur_value
	if(jsonobj['cur_value']!=null&&jsonobj['cur_value']!=undefined){
		if(typeof jsonobj['cur_value']!='string'){
			throw 'KeyConfigInfo.cur_value must be string'
		}
		obj['cur_value']=jsonobj['cur_value']
	}
	//cur_value_type
	if(jsonobj['cur_value_type']!=null&&jsonobj['cur_value_type']!=undefined){
		if(typeof jsonobj['cur_value_type']!='string'){
			throw 'KeyConfigInfo.cur_value_type must be string'
		}
		obj['cur_value_type']=jsonobj['cur_value_type']
	}
	return obj
}
export interface ProxyPathInfo{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	node_id: Array<number>|null|undefined;
	read: boolean;//need read permission on this node
	write: boolean;//need write permission on this node
	admin: boolean;//need admin permission on this node
}
function JsonToProxyPathInfo(jsonobj: { [k:string]:any }): ProxyPathInfo{
	let obj: ProxyPathInfo={
		node_id:null,
		read:false,
		write:false,
		admin:false,
	}
	//node_id
	if(jsonobj['node_id']!=null&&jsonobj['node_id']!=undefined){
		if(!(jsonobj['node_id'] instanceof Array)){
			throw 'ProxyPathInfo.node_id must be Array<number>|null|undefined'
		}
		for(let element of jsonobj['node_id']){
			if(typeof element!='number'||!Number.isInteger(element)){
				throw 'element in ProxyPathInfo.node_id must be integer'
			}else if(element>4294967295||element<0){
				throw 'element in ProxyPathInfo.node_id overflow'
			}
			if(obj['node_id']==null){
				obj['node_id']=new Array<number>
			}
			obj['node_id'].push(element)
		}
	}
	//read
	if(jsonobj['read']!=null&&jsonobj['read']!=undefined){
		if(typeof jsonobj['read']!='boolean'){
			throw 'ProxyPathInfo.read must be boolean'
		}
		obj['read']=jsonobj['read']
	}
	//write
	if(jsonobj['write']!=null&&jsonobj['write']!=undefined){
		if(typeof jsonobj['write']!='boolean'){
			throw 'ProxyPathInfo.write must be boolean'
		}
		obj['write']=jsonobj['write']
	}
	//admin
	if(jsonobj['admin']!=null&&jsonobj['admin']!=undefined){
		if(typeof jsonobj['admin']!='boolean'){
			throw 'ProxyPathInfo.admin must be boolean'
		}
		obj['admin']=jsonobj['admin']
	}
	return obj
}
export interface ProxyReq{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	project_id: Array<number>|null|undefined;
	g_name: string;
	a_name: string;
	path: string;
	data: string;
	force_addr: string;
}
function ProxyReqToJson(msg: ProxyReq): string{
	let s: string="{"
	//project_id
	if(msg.project_id==null||msg.project_id==undefined){
		s+='"project_id":null,'
	}else if(msg.project_id.length==0){
		s+='"project_id":[],'
	}else{
		s+='"project_id":['
		for(let element of msg.project_id){
			if(element==null||element==undefined||!Number.isInteger(element)){
				throw 'element in ProxyReq.project_id must be integer'
			}
			if(element>4294967295||element<0){
				throw 'element in ProxyReq.project_id overflow'
			}
			s+=element+','
		}
		s=s.substr(0,s.length-1)+'],'
	}
	//g_name
	if(msg.g_name==null||msg.g_name==undefined){
		throw 'ProxyReq.g_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.g_name)
		s+='"g_name":'+vv+','
	}
	//a_name
	if(msg.a_name==null||msg.a_name==undefined){
		throw 'ProxyReq.a_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.a_name)
		s+='"a_name":'+vv+','
	}
	//path
	if(msg.path==null||msg.path==undefined){
		throw 'ProxyReq.path must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.path)
		s+='"path":'+vv+','
	}
	//data
	if(msg.data==null||msg.data==undefined){
		throw 'ProxyReq.data must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.data)
		s+='"data":'+vv+','
	}
	//force_addr
	if(msg.force_addr==null||msg.force_addr==undefined){
		throw 'ProxyReq.force_addr must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.force_addr)
		s+='"force_addr":'+vv+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface ProxyResp{
	data: string;
}
function JsonToProxyResp(jsonobj: { [k:string]:any }): ProxyResp{
	let obj: ProxyResp={
		data:'',
	}
	//data
	if(jsonobj['data']!=null&&jsonobj['data']!=undefined){
		if(typeof jsonobj['data']!='string'){
			throw 'ProxyResp.data must be string'
		}
		obj['data']=jsonobj['data']
	}
	return obj
}
export interface RollbackReq{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	project_id: Array<number>|null|undefined;
	g_name: string;
	a_name: string;
	key: string;//can't contain '.' in key
	secret: string;
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	index: number;
}
function RollbackReqToJson(msg: RollbackReq): string{
	let s: string="{"
	//project_id
	if(msg.project_id==null||msg.project_id==undefined){
		s+='"project_id":null,'
	}else if(msg.project_id.length==0){
		s+='"project_id":[],'
	}else{
		s+='"project_id":['
		for(let element of msg.project_id){
			if(element==null||element==undefined||!Number.isInteger(element)){
				throw 'element in RollbackReq.project_id must be integer'
			}
			if(element>4294967295||element<0){
				throw 'element in RollbackReq.project_id overflow'
			}
			s+=element+','
		}
		s=s.substr(0,s.length-1)+'],'
	}
	//g_name
	if(msg.g_name==null||msg.g_name==undefined){
		throw 'RollbackReq.g_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.g_name)
		s+='"g_name":'+vv+','
	}
	//a_name
	if(msg.a_name==null||msg.a_name==undefined){
		throw 'RollbackReq.a_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.a_name)
		s+='"a_name":'+vv+','
	}
	//key
	if(msg.key==null||msg.key==undefined){
		throw 'RollbackReq.key must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.key)
		s+='"key":'+vv+','
	}
	//secret
	if(msg.secret==null||msg.secret==undefined){
		throw 'RollbackReq.secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.secret)
		s+='"secret":'+vv+','
	}
	//index
	if(msg.index==null||msg.index==undefined||!Number.isInteger(msg.index)){
		throw 'RollbackReq.index must be integer'
	}else if(msg.index>4294967295||msg.index<0){
		throw 'RollbackReq.index overflow'
	}else{
		s+='"index":'+msg.index+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface RollbackResp{
}
function JsonToRollbackResp(_jsonobj: { [k:string]:any }): RollbackResp{
	let obj: RollbackResp={
	}
	return obj
}
export interface SetAppReq{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	project_id: Array<number>|null|undefined;
	g_name: string;
	a_name: string;
	secret: string;
	discover_mode: string;
	kubernetes_namespace: string;//when discover_mode == "kubernetes"
	kubernetes_labelselector: string;//when discover_mode == "kubernetes"
	kubernetes_fieldselector: string;//when discover_mode == "kubernetes"
	dns_host: string;//when discover_mode == "dns"
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	dns_interval: number;//when discover_mode == "dns"
	static_addrs: Array<string>|null|undefined;//when discover_mode == "static"
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	crpc_port: number;
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	cgrpc_port: number;
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	web_port: number;
	new_app: boolean;//true: create a new app. false: update the already exist app
}
function SetAppReqToJson(msg: SetAppReq): string{
	let s: string="{"
	//project_id
	if(msg.project_id==null||msg.project_id==undefined){
		s+='"project_id":null,'
	}else if(msg.project_id.length==0){
		s+='"project_id":[],'
	}else{
		s+='"project_id":['
		for(let element of msg.project_id){
			if(element==null||element==undefined||!Number.isInteger(element)){
				throw 'element in SetAppReq.project_id must be integer'
			}
			if(element>4294967295||element<0){
				throw 'element in SetAppReq.project_id overflow'
			}
			s+=element+','
		}
		s=s.substr(0,s.length-1)+'],'
	}
	//g_name
	if(msg.g_name==null||msg.g_name==undefined){
		throw 'SetAppReq.g_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.g_name)
		s+='"g_name":'+vv+','
	}
	//a_name
	if(msg.a_name==null||msg.a_name==undefined){
		throw 'SetAppReq.a_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.a_name)
		s+='"a_name":'+vv+','
	}
	//secret
	if(msg.secret==null||msg.secret==undefined){
		throw 'SetAppReq.secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.secret)
		s+='"secret":'+vv+','
	}
	//discover_mode
	if(msg.discover_mode==null||msg.discover_mode==undefined){
		throw 'SetAppReq.discover_mode must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.discover_mode)
		s+='"discover_mode":'+vv+','
	}
	//kubernetes_namespace
	if(msg.kubernetes_namespace==null||msg.kubernetes_namespace==undefined){
		throw 'SetAppReq.kubernetes_namespace must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.kubernetes_namespace)
		s+='"kubernetes_namespace":'+vv+','
	}
	//kubernetes_labelselector
	if(msg.kubernetes_labelselector==null||msg.kubernetes_labelselector==undefined){
		throw 'SetAppReq.kubernetes_labelselector must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.kubernetes_labelselector)
		s+='"kubernetes_labelselector":'+vv+','
	}
	//kubernetes_fieldselector
	if(msg.kubernetes_fieldselector==null||msg.kubernetes_fieldselector==undefined){
		throw 'SetAppReq.kubernetes_fieldselector must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.kubernetes_fieldselector)
		s+='"kubernetes_fieldselector":'+vv+','
	}
	//dns_host
	if(msg.dns_host==null||msg.dns_host==undefined){
		throw 'SetAppReq.dns_host must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.dns_host)
		s+='"dns_host":'+vv+','
	}
	//dns_interval
	if(msg.dns_interval==null||msg.dns_interval==undefined||!Number.isInteger(msg.dns_interval)){
		throw 'SetAppReq.dns_interval must be integer'
	}else if(msg.dns_interval>4294967295||msg.dns_interval<0){
		throw 'SetAppReq.dns_interval overflow'
	}else{
		s+='"dns_interval":'+msg.dns_interval+','
	}
	//static_addrs
	if(msg.static_addrs==null||msg.static_addrs==undefined){
		s+='"static_addrs":null,'
	}else if(msg.static_addrs.length==0){
		s+='"static_addrs":[],'
	}else{
		s+='"static_addrs":['
		for(let element of msg.static_addrs){
			if(element==null||element==undefined){
				throw 'element in SetAppReq.static_addrs must be string'
			}
			//transfer the json escape
			let vv=JSON.stringify(element)
			s+=vv+','
		}
		s=s.substr(0,s.length-1)+'],'
	}
	//crpc_port
	if(msg.crpc_port==null||msg.crpc_port==undefined||!Number.isInteger(msg.crpc_port)){
		throw 'SetAppReq.crpc_port must be integer'
	}else if(msg.crpc_port>4294967295||msg.crpc_port<0){
		throw 'SetAppReq.crpc_port overflow'
	}else{
		s+='"crpc_port":'+msg.crpc_port+','
	}
	//cgrpc_port
	if(msg.cgrpc_port==null||msg.cgrpc_port==undefined||!Number.isInteger(msg.cgrpc_port)){
		throw 'SetAppReq.cgrpc_port must be integer'
	}else if(msg.cgrpc_port>4294967295||msg.cgrpc_port<0){
		throw 'SetAppReq.cgrpc_port overflow'
	}else{
		s+='"cgrpc_port":'+msg.cgrpc_port+','
	}
	//web_port
	if(msg.web_port==null||msg.web_port==undefined||!Number.isInteger(msg.web_port)){
		throw 'SetAppReq.web_port must be integer'
	}else if(msg.web_port>4294967295||msg.web_port<0){
		throw 'SetAppReq.web_port overflow'
	}else{
		s+='"web_port":'+msg.web_port+','
	}
	//new_app
	if(msg.new_app==null||msg.new_app==undefined){
		throw 'SetAppReq.new_app must be boolean'
	}else{
		s+='"new_app":'+msg.new_app+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface SetAppResp{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	node_id: Array<number>|null|undefined;
}
function JsonToSetAppResp(jsonobj: { [k:string]:any }): SetAppResp{
	let obj: SetAppResp={
		node_id:null,
	}
	//node_id
	if(jsonobj['node_id']!=null&&jsonobj['node_id']!=undefined){
		if(!(jsonobj['node_id'] instanceof Array)){
			throw 'SetAppResp.node_id must be Array<number>|null|undefined'
		}
		for(let element of jsonobj['node_id']){
			if(typeof element!='number'||!Number.isInteger(element)){
				throw 'element in SetAppResp.node_id must be integer'
			}else if(element>4294967295||element<0){
				throw 'element in SetAppResp.node_id overflow'
			}
			if(obj['node_id']==null){
				obj['node_id']=new Array<number>
			}
			obj['node_id'].push(element)
		}
	}
	return obj
}
export interface SetKeyConfigReq{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	project_id: Array<number>|null|undefined;
	g_name: string;
	a_name: string;
	key: string;//can't contain '.' in key
	value: string;
	value_type: string;
	secret: string;
	new_key: boolean;//true: create a new key config. false: update the already exist key config
}
function SetKeyConfigReqToJson(msg: SetKeyConfigReq): string{
	let s: string="{"
	//project_id
	if(msg.project_id==null||msg.project_id==undefined){
		s+='"project_id":null,'
	}else if(msg.project_id.length==0){
		s+='"project_id":[],'
	}else{
		s+='"project_id":['
		for(let element of msg.project_id){
			if(element==null||element==undefined||!Number.isInteger(element)){
				throw 'element in SetKeyConfigReq.project_id must be integer'
			}
			if(element>4294967295||element<0){
				throw 'element in SetKeyConfigReq.project_id overflow'
			}
			s+=element+','
		}
		s=s.substr(0,s.length-1)+'],'
	}
	//g_name
	if(msg.g_name==null||msg.g_name==undefined){
		throw 'SetKeyConfigReq.g_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.g_name)
		s+='"g_name":'+vv+','
	}
	//a_name
	if(msg.a_name==null||msg.a_name==undefined){
		throw 'SetKeyConfigReq.a_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.a_name)
		s+='"a_name":'+vv+','
	}
	//key
	if(msg.key==null||msg.key==undefined){
		throw 'SetKeyConfigReq.key must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.key)
		s+='"key":'+vv+','
	}
	//value
	if(msg.value==null||msg.value==undefined){
		throw 'SetKeyConfigReq.value must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.value)
		s+='"value":'+vv+','
	}
	//value_type
	if(msg.value_type==null||msg.value_type==undefined){
		throw 'SetKeyConfigReq.value_type must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.value_type)
		s+='"value_type":'+vv+','
	}
	//secret
	if(msg.secret==null||msg.secret==undefined){
		throw 'SetKeyConfigReq.secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.secret)
		s+='"secret":'+vv+','
	}
	//new_key
	if(msg.new_key==null||msg.new_key==undefined){
		throw 'SetKeyConfigReq.new_key must be boolean'
	}else{
		s+='"new_key":'+msg.new_key+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface SetKeyConfigResp{
}
function JsonToSetKeyConfigResp(_jsonobj: { [k:string]:any }): SetKeyConfigResp{
	let obj: SetKeyConfigResp={
	}
	return obj
}
export interface SetProxyReq{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	project_id: Array<number>|null|undefined;
	g_name: string;
	a_name: string;
	path: string;
	read: boolean;//need read permission on this node
	write: boolean;//need write permission on this node
	admin: boolean;//need admin permission on this node
	secret: string;
	new_path: boolean;//true: create a new proxy path config. false: update the already exist proxy path setting
}
function SetProxyReqToJson(msg: SetProxyReq): string{
	let s: string="{"
	//project_id
	if(msg.project_id==null||msg.project_id==undefined){
		s+='"project_id":null,'
	}else if(msg.project_id.length==0){
		s+='"project_id":[],'
	}else{
		s+='"project_id":['
		for(let element of msg.project_id){
			if(element==null||element==undefined||!Number.isInteger(element)){
				throw 'element in SetProxyReq.project_id must be integer'
			}
			if(element>4294967295||element<0){
				throw 'element in SetProxyReq.project_id overflow'
			}
			s+=element+','
		}
		s=s.substr(0,s.length-1)+'],'
	}
	//g_name
	if(msg.g_name==null||msg.g_name==undefined){
		throw 'SetProxyReq.g_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.g_name)
		s+='"g_name":'+vv+','
	}
	//a_name
	if(msg.a_name==null||msg.a_name==undefined){
		throw 'SetProxyReq.a_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.a_name)
		s+='"a_name":'+vv+','
	}
	//path
	if(msg.path==null||msg.path==undefined){
		throw 'SetProxyReq.path must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.path)
		s+='"path":'+vv+','
	}
	//read
	if(msg.read==null||msg.read==undefined){
		throw 'SetProxyReq.read must be boolean'
	}else{
		s+='"read":'+msg.read+','
	}
	//write
	if(msg.write==null||msg.write==undefined){
		throw 'SetProxyReq.write must be boolean'
	}else{
		s+='"write":'+msg.write+','
	}
	//admin
	if(msg.admin==null||msg.admin==undefined){
		throw 'SetProxyReq.admin must be boolean'
	}else{
		s+='"admin":'+msg.admin+','
	}
	//secret
	if(msg.secret==null||msg.secret==undefined){
		throw 'SetProxyReq.secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.secret)
		s+='"secret":'+vv+','
	}
	//new_path
	if(msg.new_path==null||msg.new_path==undefined){
		throw 'SetProxyReq.new_path must be boolean'
	}else{
		s+='"new_path":'+msg.new_path+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface SetProxyResp{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	node_id: Array<number>|null|undefined;
}
function JsonToSetProxyResp(jsonobj: { [k:string]:any }): SetProxyResp{
	let obj: SetProxyResp={
		node_id:null,
	}
	//node_id
	if(jsonobj['node_id']!=null&&jsonobj['node_id']!=undefined){
		if(!(jsonobj['node_id'] instanceof Array)){
			throw 'SetProxyResp.node_id must be Array<number>|null|undefined'
		}
		for(let element of jsonobj['node_id']){
			if(typeof element!='number'||!Number.isInteger(element)){
				throw 'element in SetProxyResp.node_id must be integer'
			}else if(element>4294967295||element<0){
				throw 'element in SetProxyResp.node_id overflow'
			}
			if(obj['node_id']==null){
				obj['node_id']=new Array<number>
			}
			obj['node_id'].push(element)
		}
	}
	return obj
}
export interface UpdateAppSecretReq{
	//Warning!!!Element type is uint32,be careful of sign(+) and overflow
	project_id: Array<number>|null|undefined;
	g_name: string;
	a_name: string;
	old_secret: string;
	new_secret: string;
}
function UpdateAppSecretReqToJson(msg: UpdateAppSecretReq): string{
	let s: string="{"
	//project_id
	if(msg.project_id==null||msg.project_id==undefined){
		s+='"project_id":null,'
	}else if(msg.project_id.length==0){
		s+='"project_id":[],'
	}else{
		s+='"project_id":['
		for(let element of msg.project_id){
			if(element==null||element==undefined||!Number.isInteger(element)){
				throw 'element in UpdateAppSecretReq.project_id must be integer'
			}
			if(element>4294967295||element<0){
				throw 'element in UpdateAppSecretReq.project_id overflow'
			}
			s+=element+','
		}
		s=s.substr(0,s.length-1)+'],'
	}
	//g_name
	if(msg.g_name==null||msg.g_name==undefined){
		throw 'UpdateAppSecretReq.g_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.g_name)
		s+='"g_name":'+vv+','
	}
	//a_name
	if(msg.a_name==null||msg.a_name==undefined){
		throw 'UpdateAppSecretReq.a_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.a_name)
		s+='"a_name":'+vv+','
	}
	//old_secret
	if(msg.old_secret==null||msg.old_secret==undefined){
		throw 'UpdateAppSecretReq.old_secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.old_secret)
		s+='"old_secret":'+vv+','
	}
	//new_secret
	if(msg.new_secret==null||msg.new_secret==undefined){
		throw 'UpdateAppSecretReq.new_secret must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.new_secret)
		s+='"new_secret":'+vv+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface UpdateAppSecretResp{
}
function JsonToUpdateAppSecretResp(_jsonobj: { [k:string]:any }): UpdateAppSecretResp{
	let obj: UpdateAppSecretResp={
	}
	return obj
}
export interface WatchConfigReq{
	project_name: string;
	g_name: string;
	a_name: string;
	//map's key is config's keyname,map's value is config's cur version
	//if cur version == 0 means return current active config
	//if all cur version is the newest,the request will block until a new version come
	//if some keys' version is the newest,and some keys' version is old,then the keys with old version will return newest version and datas,the newest's keys will only return version
	//Warning!!!map's value's type is uint32,be careful of sign(+) and overflow
	keys: Map<string,number>|null|undefined;//can't contain '.' in key
}
function WatchConfigReqToJson(msg: WatchConfigReq): string{
	let s: string="{"
	//project_name
	if(msg.project_name==null||msg.project_name==undefined){
		throw 'WatchConfigReq.project_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.project_name)
		s+='"project_name":'+vv+','
	}
	//g_name
	if(msg.g_name==null||msg.g_name==undefined){
		throw 'WatchConfigReq.g_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.g_name)
		s+='"g_name":'+vv+','
	}
	//a_name
	if(msg.a_name==null||msg.a_name==undefined){
		throw 'WatchConfigReq.a_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.a_name)
		s+='"a_name":'+vv+','
	}
	//keys
	if(msg.keys==null||msg.keys==undefined){
		s+='"keys":null,'
	}else if (msg.keys.size==0){
		s+='"keys":{},'
	}else{
		s+='"keys":{'
		for(let kv of msg.keys.entries()){
			if(kv[0]==null||kv[0]==undefined){
				throw "map's key in WatchConfigReq.keys must be string"
			}
			//transfer the json escape
			let vv=JSON.stringify(kv[0])
			s+=vv+':'
			if(kv[1]==null||kv[1]==undefined||!Number.isInteger(kv[1])){
				throw "map's value in WatchConfigReq.keys must be integer"
			}else if(kv[1]>4294967295||kv[1]<0){
				throw "map's value in WatchConfigReq.keys overflow"
			}
			s+=kv[1]+','
		}
		s=s.substr(0,s.length-1)+'},'
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface WatchConfigResp{
	datas: Map<string,WatchData|null|undefined>|null|undefined;
}
function JsonToWatchConfigResp(jsonobj: { [k:string]:any }): WatchConfigResp{
	let obj: WatchConfigResp={
		datas:null,
	}
	//datas
	if(jsonobj['datas']!=null&&jsonobj['datas']!=undefined){
		if(typeof jsonobj['datas']!='object'){
			throw 'WatchConfigResp.datas must be Map<string,WatchData|null|undefined>|null|undefined'
		}
		for(let key of Object.keys(jsonobj['datas'])){
			let value=jsonobj['datas'][key]
			let k: string=key
			let v: WatchData|null|undefined=null
			if(typeof value==null||typeof value==undefined){
				v=null
			}else if(typeof value!='object'){
				throw 'value in WatchConfigResp.datas must be WatchData|null|undefined'
			}else{
				v=JsonToWatchData(value)
			}
			if(obj['datas']==undefined){
				obj['datas']=new Map<string,WatchData|null|undefined>
			}
			obj['datas'].set(k,v)
		}
	}
	return obj
}
export interface WatchData{
	key: string;
	value: string;
	value_type: string;
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	version: number;
}
function JsonToWatchData(jsonobj: { [k:string]:any }): WatchData{
	let obj: WatchData={
		key:'',
		value:'',
		value_type:'',
		version:0,
	}
	//key
	if(jsonobj['key']!=null&&jsonobj['key']!=undefined){
		if(typeof jsonobj['key']!='string'){
			throw 'WatchData.key must be string'
		}
		obj['key']=jsonobj['key']
	}
	//value
	if(jsonobj['value']!=null&&jsonobj['value']!=undefined){
		if(typeof jsonobj['value']!='string'){
			throw 'WatchData.value must be string'
		}
		obj['value']=jsonobj['value']
	}
	//value_type
	if(jsonobj['value_type']!=null&&jsonobj['value_type']!=undefined){
		if(typeof jsonobj['value_type']!='string'){
			throw 'WatchData.value_type must be string'
		}
		obj['value_type']=jsonobj['value_type']
	}
	//version
	if(jsonobj['version']!=null&&jsonobj['version']!=undefined){
		if(typeof jsonobj['version']!='number'||!Number.isInteger(jsonobj['version'])){
			throw 'WatchData.version must be integer'
		}else if(jsonobj['version']>4294967295||jsonobj['version']<0){
			throw 'WatchData.version overflow'
		}
		obj['version']=jsonobj['version']
	}
	return obj
}
export interface WatchDiscoverReq{
	project_name: string;
	g_name: string;
	a_name: string;
	cur_discover_mode: string;
	cur_dns_host: string;//when discover_mode == "dns"
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	cur_dns_interval: number;//when discover_mode == "dns"
	cur_addrs: Array<string>|null|undefined;//when discover_mode == "static" or "kubernetes"
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	crpc_port: number;
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	cgrpc_port: number;
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	web_port: number;
}
function WatchDiscoverReqToJson(msg: WatchDiscoverReq): string{
	let s: string="{"
	//project_name
	if(msg.project_name==null||msg.project_name==undefined){
		throw 'WatchDiscoverReq.project_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.project_name)
		s+='"project_name":'+vv+','
	}
	//g_name
	if(msg.g_name==null||msg.g_name==undefined){
		throw 'WatchDiscoverReq.g_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.g_name)
		s+='"g_name":'+vv+','
	}
	//a_name
	if(msg.a_name==null||msg.a_name==undefined){
		throw 'WatchDiscoverReq.a_name must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.a_name)
		s+='"a_name":'+vv+','
	}
	//cur_discover_mode
	if(msg.cur_discover_mode==null||msg.cur_discover_mode==undefined){
		throw 'WatchDiscoverReq.cur_discover_mode must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.cur_discover_mode)
		s+='"cur_discover_mode":'+vv+','
	}
	//cur_dns_host
	if(msg.cur_dns_host==null||msg.cur_dns_host==undefined){
		throw 'WatchDiscoverReq.cur_dns_host must be string'
	}else{
		//transfer the json escape
		let vv=JSON.stringify(msg.cur_dns_host)
		s+='"cur_dns_host":'+vv+','
	}
	//cur_dns_interval
	if(msg.cur_dns_interval==null||msg.cur_dns_interval==undefined||!Number.isInteger(msg.cur_dns_interval)){
		throw 'WatchDiscoverReq.cur_dns_interval must be integer'
	}else if(msg.cur_dns_interval>4294967295||msg.cur_dns_interval<0){
		throw 'WatchDiscoverReq.cur_dns_interval overflow'
	}else{
		s+='"cur_dns_interval":'+msg.cur_dns_interval+','
	}
	//cur_addrs
	if(msg.cur_addrs==null||msg.cur_addrs==undefined){
		s+='"cur_addrs":null,'
	}else if(msg.cur_addrs.length==0){
		s+='"cur_addrs":[],'
	}else{
		s+='"cur_addrs":['
		for(let element of msg.cur_addrs){
			if(element==null||element==undefined){
				throw 'element in WatchDiscoverReq.cur_addrs must be string'
			}
			//transfer the json escape
			let vv=JSON.stringify(element)
			s+=vv+','
		}
		s=s.substr(0,s.length-1)+'],'
	}
	//crpc_port
	if(msg.crpc_port==null||msg.crpc_port==undefined||!Number.isInteger(msg.crpc_port)){
		throw 'WatchDiscoverReq.crpc_port must be integer'
	}else if(msg.crpc_port>4294967295||msg.crpc_port<0){
		throw 'WatchDiscoverReq.crpc_port overflow'
	}else{
		s+='"crpc_port":'+msg.crpc_port+','
	}
	//cgrpc_port
	if(msg.cgrpc_port==null||msg.cgrpc_port==undefined||!Number.isInteger(msg.cgrpc_port)){
		throw 'WatchDiscoverReq.cgrpc_port must be integer'
	}else if(msg.cgrpc_port>4294967295||msg.cgrpc_port<0){
		throw 'WatchDiscoverReq.cgrpc_port overflow'
	}else{
		s+='"cgrpc_port":'+msg.cgrpc_port+','
	}
	//web_port
	if(msg.web_port==null||msg.web_port==undefined||!Number.isInteger(msg.web_port)){
		throw 'WatchDiscoverReq.web_port must be integer'
	}else if(msg.web_port>4294967295||msg.web_port<0){
		throw 'WatchDiscoverReq.web_port overflow'
	}else{
		s+='"web_port":'+msg.web_port+','
	}
	if(s.length==1){
		s+="}"
	}else{
		s=s.substr(0,s.length-1)+'}'
	}
	return s
}
export interface WatchDiscoverResp{
	discover_mode: string;
	dns_host: string;//when discover_mode == "dns"
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	dns_interval: number;//when discover_mode == "dns"
	addrs: Array<string>|null|undefined;//when discover_mode == "static"
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	crpc_port: number;
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	cgrpc_port: number;
	//Warning!!!Type is uint32,be careful of sign(+) and overflow
	web_port: number;
}
function JsonToWatchDiscoverResp(jsonobj: { [k:string]:any }): WatchDiscoverResp{
	let obj: WatchDiscoverResp={
		discover_mode:'',
		dns_host:'',
		dns_interval:0,
		addrs:null,
		crpc_port:0,
		cgrpc_port:0,
		web_port:0,
	}
	//discover_mode
	if(jsonobj['discover_mode']!=null&&jsonobj['discover_mode']!=undefined){
		if(typeof jsonobj['discover_mode']!='string'){
			throw 'WatchDiscoverResp.discover_mode must be string'
		}
		obj['discover_mode']=jsonobj['discover_mode']
	}
	//dns_host
	if(jsonobj['dns_host']!=null&&jsonobj['dns_host']!=undefined){
		if(typeof jsonobj['dns_host']!='string'){
			throw 'WatchDiscoverResp.dns_host must be string'
		}
		obj['dns_host']=jsonobj['dns_host']
	}
	//dns_interval
	if(jsonobj['dns_interval']!=null&&jsonobj['dns_interval']!=undefined){
		if(typeof jsonobj['dns_interval']!='number'||!Number.isInteger(jsonobj['dns_interval'])){
			throw 'WatchDiscoverResp.dns_interval must be integer'
		}else if(jsonobj['dns_interval']>4294967295||jsonobj['dns_interval']<0){
			throw 'WatchDiscoverResp.dns_interval overflow'
		}
		obj['dns_interval']=jsonobj['dns_interval']
	}
	//addrs
	if(jsonobj['addrs']!=null&&jsonobj['addrs']!=undefined){
		if(!(jsonobj['addrs'] instanceof Array)){
			throw 'WatchDiscoverResp.addrs must be Array<string>|null|undefined'
		}
		for(let element of jsonobj['addrs']){
			if(typeof element!='string'){
				throw 'element in WatchDiscoverResp.addrs must be string'
			}
			if(obj['addrs']==null){
				obj['addrs']=new Array<string>
			}
			obj['addrs'].push(element)
		}
	}
	//crpc_port
	if(jsonobj['crpc_port']!=null&&jsonobj['crpc_port']!=undefined){
		if(typeof jsonobj['crpc_port']!='number'||!Number.isInteger(jsonobj['crpc_port'])){
			throw 'WatchDiscoverResp.crpc_port must be integer'
		}else if(jsonobj['crpc_port']>4294967295||jsonobj['crpc_port']<0){
			throw 'WatchDiscoverResp.crpc_port overflow'
		}
		obj['crpc_port']=jsonobj['crpc_port']
	}
	//cgrpc_port
	if(jsonobj['cgrpc_port']!=null&&jsonobj['cgrpc_port']!=undefined){
		if(typeof jsonobj['cgrpc_port']!='number'||!Number.isInteger(jsonobj['cgrpc_port'])){
			throw 'WatchDiscoverResp.cgrpc_port must be integer'
		}else if(jsonobj['cgrpc_port']>4294967295||jsonobj['cgrpc_port']<0){
			throw 'WatchDiscoverResp.cgrpc_port overflow'
		}
		obj['cgrpc_port']=jsonobj['cgrpc_port']
	}
	//web_port
	if(jsonobj['web_port']!=null&&jsonobj['web_port']!=undefined){
		if(typeof jsonobj['web_port']!='number'||!Number.isInteger(jsonobj['web_port'])){
			throw 'WatchDiscoverResp.web_port must be integer'
		}else if(jsonobj['web_port']>4294967295||jsonobj['web_port']<0){
			throw 'WatchDiscoverResp.web_port overflow'
		}
		obj['web_port']=jsonobj['web_port']
	}
	return obj
}
const _WebPathAppGetApp: string ="/admin.app/get_app";
const _WebPathAppSetApp: string ="/admin.app/set_app";
const _WebPathAppDelApp: string ="/admin.app/del_app";
const _WebPathAppUpdateAppSecret: string ="/admin.app/update_app_secret";
const _WebPathAppDelKey: string ="/admin.app/del_key";
const _WebPathAppGetKeyConfig: string ="/admin.app/get_key_config";
const _WebPathAppSetKeyConfig: string ="/admin.app/set_key_config";
const _WebPathAppRollback: string ="/admin.app/rollback";
const _WebPathAppWatchConfig: string ="/admin.app/watch_config";
const _WebPathAppWatchDiscover: string ="/admin.app/watch_discover";
const _WebPathAppGetInstances: string ="/admin.app/get_instances";
const _WebPathAppGetInstanceInfo: string ="/admin.app/get_instance_info";
const _WebPathAppSetProxy: string ="/admin.app/set_proxy";
const _WebPathAppDelProxy: string ="/admin.app/del_proxy";
const _WebPathAppProxy: string ="/admin.app/proxy";
//ToC means this is used for users
export class AppBrowserClientToC {
	constructor(host: string){
		if(host==null||host==undefined||host.length==0){
			throw "AppBrowserClientToC's host missing"
		}
		this.host=host
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	get_app(header: { [k: string]: string },req: GetAppReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: GetAppResp)=>void){
		if(!Number.isInteger(timeout)){
			errorf({code:-2,msg:'timeout must be integer'})
			return
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let body: string=''
		try{
			body=GetAppReqToJson(req)
		}catch(e){
			errorf({code:-2,msg:''+e})
			return
		}
		let config={
			url:_WebPathAppGetApp,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: body,
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			let obj:GetAppResp
			try{
				obj=JsonToGetAppResp(response.data)
			}catch(e){
				let err:Error={code:-1,msg:'response body decode failed'}
				errorf(err)
				return
			}
			try{
			successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'success callback run failed'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	set_app(header: { [k: string]: string },req: SetAppReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: SetAppResp)=>void){
		if(!Number.isInteger(timeout)){
			errorf({code:-2,msg:'timeout must be integer'})
			return
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let body: string=''
		try{
			body=SetAppReqToJson(req)
		}catch(e){
			errorf({code:-2,msg:''+e})
			return
		}
		let config={
			url:_WebPathAppSetApp,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: body,
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			let obj:SetAppResp
			try{
				obj=JsonToSetAppResp(response.data)
			}catch(e){
				let err:Error={code:-1,msg:'response body decode failed'}
				errorf(err)
				return
			}
			try{
			successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'success callback run failed'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	del_app(header: { [k: string]: string },req: DelAppReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: DelAppResp)=>void){
		if(!Number.isInteger(timeout)){
			errorf({code:-2,msg:'timeout must be integer'})
			return
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let body: string=''
		try{
			body=DelAppReqToJson(req)
		}catch(e){
			errorf({code:-2,msg:''+e})
			return
		}
		let config={
			url:_WebPathAppDelApp,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: body,
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			let obj:DelAppResp
			try{
				obj=JsonToDelAppResp(response.data)
			}catch(e){
				let err:Error={code:-1,msg:'response body decode failed'}
				errorf(err)
				return
			}
			try{
			successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'success callback run failed'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	update_app_secret(header: { [k: string]: string },req: UpdateAppSecretReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: UpdateAppSecretResp)=>void){
		if(!Number.isInteger(timeout)){
			errorf({code:-2,msg:'timeout must be integer'})
			return
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let body: string=''
		try{
			body=UpdateAppSecretReqToJson(req)
		}catch(e){
			errorf({code:-2,msg:''+e})
			return
		}
		let config={
			url:_WebPathAppUpdateAppSecret,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: body,
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			let obj:UpdateAppSecretResp
			try{
				obj=JsonToUpdateAppSecretResp(response.data)
			}catch(e){
				let err:Error={code:-1,msg:'response body decode failed'}
				errorf(err)
				return
			}
			try{
			successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'success callback run failed'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	del_key(header: { [k: string]: string },req: DelKeyReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: DelKeyResp)=>void){
		if(!Number.isInteger(timeout)){
			errorf({code:-2,msg:'timeout must be integer'})
			return
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let body: string=''
		try{
			body=DelKeyReqToJson(req)
		}catch(e){
			errorf({code:-2,msg:''+e})
			return
		}
		let config={
			url:_WebPathAppDelKey,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: body,
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			let obj:DelKeyResp
			try{
				obj=JsonToDelKeyResp(response.data)
			}catch(e){
				let err:Error={code:-1,msg:'response body decode failed'}
				errorf(err)
				return
			}
			try{
			successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'success callback run failed'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	get_key_config(header: { [k: string]: string },req: GetKeyConfigReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: GetKeyConfigResp)=>void){
		if(!Number.isInteger(timeout)){
			errorf({code:-2,msg:'timeout must be integer'})
			return
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let body: string=''
		try{
			body=GetKeyConfigReqToJson(req)
		}catch(e){
			errorf({code:-2,msg:''+e})
			return
		}
		let config={
			url:_WebPathAppGetKeyConfig,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: body,
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			let obj:GetKeyConfigResp
			try{
				obj=JsonToGetKeyConfigResp(response.data)
			}catch(e){
				let err:Error={code:-1,msg:'response body decode failed'}
				errorf(err)
				return
			}
			try{
			successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'success callback run failed'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	set_key_config(header: { [k: string]: string },req: SetKeyConfigReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: SetKeyConfigResp)=>void){
		if(!Number.isInteger(timeout)){
			errorf({code:-2,msg:'timeout must be integer'})
			return
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let body: string=''
		try{
			body=SetKeyConfigReqToJson(req)
		}catch(e){
			errorf({code:-2,msg:''+e})
			return
		}
		let config={
			url:_WebPathAppSetKeyConfig,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: body,
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			let obj:SetKeyConfigResp
			try{
				obj=JsonToSetKeyConfigResp(response.data)
			}catch(e){
				let err:Error={code:-1,msg:'response body decode failed'}
				errorf(err)
				return
			}
			try{
			successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'success callback run failed'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	rollback(header: { [k: string]: string },req: RollbackReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: RollbackResp)=>void){
		if(!Number.isInteger(timeout)){
			errorf({code:-2,msg:'timeout must be integer'})
			return
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let body: string=''
		try{
			body=RollbackReqToJson(req)
		}catch(e){
			errorf({code:-2,msg:''+e})
			return
		}
		let config={
			url:_WebPathAppRollback,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: body,
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			let obj:RollbackResp
			try{
				obj=JsonToRollbackResp(response.data)
			}catch(e){
				let err:Error={code:-1,msg:'response body decode failed'}
				errorf(err)
				return
			}
			try{
			successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'success callback run failed'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	watch_config(header: { [k: string]: string },req: WatchConfigReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: WatchConfigResp)=>void){
		if(!Number.isInteger(timeout)){
			errorf({code:-2,msg:'timeout must be integer'})
			return
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let body: string=''
		try{
			body=WatchConfigReqToJson(req)
		}catch(e){
			errorf({code:-2,msg:''+e})
			return
		}
		let config={
			url:_WebPathAppWatchConfig,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: body,
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			let obj:WatchConfigResp
			try{
				obj=JsonToWatchConfigResp(response.data)
			}catch(e){
				let err:Error={code:-1,msg:'response body decode failed'}
				errorf(err)
				return
			}
			try{
			successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'success callback run failed'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	watch_discover(header: { [k: string]: string },req: WatchDiscoverReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: WatchDiscoverResp)=>void){
		if(!Number.isInteger(timeout)){
			errorf({code:-2,msg:'timeout must be integer'})
			return
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let body: string=''
		try{
			body=WatchDiscoverReqToJson(req)
		}catch(e){
			errorf({code:-2,msg:''+e})
			return
		}
		let config={
			url:_WebPathAppWatchDiscover,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: body,
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			let obj:WatchDiscoverResp
			try{
				obj=JsonToWatchDiscoverResp(response.data)
			}catch(e){
				let err:Error={code:-1,msg:'response body decode failed'}
				errorf(err)
				return
			}
			try{
			successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'success callback run failed'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	get_instances(header: { [k: string]: string },req: GetInstancesReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: GetInstancesResp)=>void){
		if(!Number.isInteger(timeout)){
			errorf({code:-2,msg:'timeout must be integer'})
			return
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let body: string=''
		try{
			body=GetInstancesReqToJson(req)
		}catch(e){
			errorf({code:-2,msg:''+e})
			return
		}
		let config={
			url:_WebPathAppGetInstances,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: body,
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			let obj:GetInstancesResp
			try{
				obj=JsonToGetInstancesResp(response.data)
			}catch(e){
				let err:Error={code:-1,msg:'response body decode failed'}
				errorf(err)
				return
			}
			try{
			successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'success callback run failed'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	get_instance_info(header: { [k: string]: string },req: GetInstanceInfoReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: GetInstanceInfoResp)=>void){
		if(!Number.isInteger(timeout)){
			errorf({code:-2,msg:'timeout must be integer'})
			return
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let body: string=''
		try{
			body=GetInstanceInfoReqToJson(req)
		}catch(e){
			errorf({code:-2,msg:''+e})
			return
		}
		let config={
			url:_WebPathAppGetInstanceInfo,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: body,
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			let obj:GetInstanceInfoResp
			try{
				obj=JsonToGetInstanceInfoResp(response.data)
			}catch(e){
				let err:Error={code:-1,msg:'response body decode failed'}
				errorf(err)
				return
			}
			try{
			successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'success callback run failed'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	set_proxy(header: { [k: string]: string },req: SetProxyReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: SetProxyResp)=>void){
		if(!Number.isInteger(timeout)){
			errorf({code:-2,msg:'timeout must be integer'})
			return
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let body: string=''
		try{
			body=SetProxyReqToJson(req)
		}catch(e){
			errorf({code:-2,msg:''+e})
			return
		}
		let config={
			url:_WebPathAppSetProxy,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: body,
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			let obj:SetProxyResp
			try{
				obj=JsonToSetProxyResp(response.data)
			}catch(e){
				let err:Error={code:-1,msg:'response body decode failed'}
				errorf(err)
				return
			}
			try{
			successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'success callback run failed'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	del_proxy(header: { [k: string]: string },req: DelProxyReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: DelProxyResp)=>void){
		if(!Number.isInteger(timeout)){
			errorf({code:-2,msg:'timeout must be integer'})
			return
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let body: string=''
		try{
			body=DelProxyReqToJson(req)
		}catch(e){
			errorf({code:-2,msg:''+e})
			return
		}
		let config={
			url:_WebPathAppDelProxy,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: body,
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			let obj:DelProxyResp
			try{
				obj=JsonToDelProxyResp(response.data)
			}catch(e){
				let err:Error={code:-1,msg:'response body decode failed'}
				errorf(err)
				return
			}
			try{
			successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'success callback run failed'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	//timeout must be integer,timeout's unit is millisecond
	//don't set Content-Type in header
	proxy(header: { [k: string]: string },req: ProxyReq,timeout: number,errorf: (arg: Error)=>void,successf: (arg: ProxyResp)=>void){
		if(!Number.isInteger(timeout)){
			errorf({code:-2,msg:'timeout must be integer'})
			return
		}
		if(header==null||header==undefined){
			header={}
		}
		header["Content-Type"] = "application/json"
		let body: string=''
		try{
			body=ProxyReqToJson(req)
		}catch(e){
			errorf({code:-2,msg:''+e})
			return
		}
		let config={
			url:_WebPathAppProxy,
			method: "post",
			baseURL: this.host,
			headers: header,
			data: body,
			timeout: timeout,
		}
		Axios.request(config)
		.then(function(response){
			let obj:ProxyResp
			try{
				obj=JsonToProxyResp(response.data)
			}catch(e){
				let err:Error={code:-1,msg:'response body decode failed'}
				errorf(err)
				return
			}
			try{
			successf(obj)
			}catch(e){
				let err:Error={code:-1,msg:'success callback run failed'}
				errorf(err)
			}
		})
		.catch(function(error){
			if(error.response==undefined){
				errorf({code:-2,msg:error.message})
				return
			}
			let respdata=error.response.data
			let err:Error={code:-1,msg:''}
			if(respdata.code==undefined||typeof respdata.code!='number'||!Number.isInteger(respdata.code)||respdata.msg==undefined||typeof respdata.msg!='string'){
				err.msg=respdata
			}else{
				err.code=respdata.code
				err.msg=respdata.msg
			}
			errorf(err)
		})
	}
	private host: string
}
